<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>推流配置</title>
  <link rel="stylesheet" href="/app/pages/shared.css" />
</head>
<body>
  <header class="shared-header">
    <div id="sharedNav"></div>
  </header>
  <main class="page-shell">
    <section class="page-card">
      <h1>推流配置</h1>
      <p class="soft-note">推荐流程：先在摄像头管理页保存设备，然后在这里一键套用，减少手动输入错误。</p>
      <div id="roleTip" class="role-tip"></div>
      <div class="status-line">
        <strong>当前推流状态:</strong>
        <span id="pushStatusBadge" class="badge badge-neutral">检查中</span>
        <span id="pushStatusText" class="soft-note">系统正在读取最新状态...</span>
      </div>
    </section>

    <section class="page-card">
      <h2>快速套用（来自摄像头库）</h2>
      <div class="grid two">
        <label>类型筛选
          <select id="cameraFilterType">
            <option value="">全部</option>
            <option value="rtsp">RTSP</option>
            <option value="mjpeg">MJPEG</option>
            <option value="rtmp">RTMP</option>
            <option value="gb28181">GB28181</option>
            <option value="onvif">ONVIF</option>
            <option value="usb">USB</option>
          </select>
        </label>
        <label>选择摄像头
          <select id="cameraSelect">
            <option value="">（请先刷新列表）</option>
          </select>
        </label>
      </div>
      <div class="actions">
        <button id="btnLoadCameras">刷新摄像头列表</button>
        <button id="btnApplyCamera">一键套用并保存</button>
        <button id="btnOpenCameraPage">打开摄像头管理页</button>
      </div>
    </section>

    <section class="page-card">
      <h2>基础推流参数</h2>
      <div class="grid two">
        <label>模式
          <select id="model">
            <option value="1">普通模式</option>
            <option value="2">高级模式</option>
          </select>
        </label>
        <label>输入类型
          <select id="inputType">
            <option value="video">视频文件</option>
            <option value="usb_camera">USB 摄像头</option>
            <option value="desktop">桌面</option>
            <option value="rtsp">RTSP</option>
            <option value="mjpeg">MJPEG</option>
            <option value="rtmp">RTMP</option>
            <option value="gb28181">GB28181</option>
            <option value="onvif">ONVIF</option>
          </select>
        </label>
      </div>
      <div class="grid two">
        <label>输出分辨率<input id="resolution" value="1280x720" /></label>
        <label>输出质量
          <select id="quality">
            <option value="1">高</option>
            <option value="2" selected>中</option>
            <option value="3">低</option>
            <option value="9">原画</option>
          </select>
        </label>
      </div>
      <div class="grid two">
        <label>推流码率预设
          <select id="bitratePreset">
            <option value="auto" selected>自动（跟随质量档位）</option>
            <option value="2000">流畅 2M - 适合手机观看</option>
            <option value="3500">标准 3.5M - 日常推荐</option>
            <option value="5000">高清 5M - 画质优先</option>
            <option value="8000">超清 8M - 高速网络</option>
            <option value="12000">蓝光 12M - 极高画质</option>
            <option value="custom">自定义</option>
          </select>
        </label>
        <label id="bitrateCustomWrap" style="display:none;">自定义码率（kbps）
          <input id="bitrateCustom" type="number" value="4500" min="500" max="120000" />
        </label>
      </div>
      <p class="soft-note">建议先用 3500~5000 kbps；网络不稳时可降到 2000 kbps，避免观众端缓冲卡顿。</p>
      <div class="grid two">
        <label>自动重试
          <select id="autoRetry">
            <option value="true" selected>开启</option>
            <option value="false">关闭</option>
          </select>
        </label>
        <label>重试间隔（秒）<input id="retryInterval" type="number" value="30" /></label>
      </div>
      <div class="grid two">
        <label>输入源声音
          <select id="sourceAudioEnabled">
            <option value="false" selected>关闭（默认）</option>
            <option value="true">开启</option>
          </select>
        </label>
        <label>说明
          <input value="单路推流可直接开关；多路拼屏可在下方为某一路单独打开声音。" readonly />
        </label>
      </div>
    </section>

    <section class="page-card">
      <h2>输入源详情</h2>
      <div id="panelVIDEO" class="soft-panel panel-hidden">
        <h3>视频素材</h3>
        <div class="grid two">
          <label>视频素材
            <select id="videoMaterialSelect">
              <option value="">（请先刷新素材）</option>
            </select>
          </label>
          <label>背景音频（可选）
            <select id="audioMaterialSelect">
              <option value="">（不使用）</option>
            </select>
          </label>
        </div>
        <div class="actions">
          <button id="btnLoadMaterialSources">刷新素材列表</button>
        </div>
        <div id="videoMaterialHint" class="soft-note">请选择一个视频素材作为推流输入源。</div>
      </div>
      <div id="panelRTSP" class="soft-panel panel-hidden">
        <h3>RTSP</h3>
        <label>RTSP URL<input id="rtspUrl" placeholder="rtsp://user:pass@ip/stream" /></label>
      </div>
      <div id="panelMJPEG" class="soft-panel panel-hidden">
        <h3>MJPEG</h3>
        <label>MJPEG URL<input id="mjpegUrl" placeholder="http://ip:port/mjpeg" /></label>
      </div>
      <div id="panelRTMP" class="soft-panel panel-hidden">
        <h3>RTMP</h3>
        <label>RTMP URL<input id="rtmpUrl" placeholder="rtmp://ip/app/stream" /></label>
      </div>
      <div id="panelGB28181" class="soft-panel panel-hidden">
        <h3>GB28181</h3>
        <label>Pull URL<input id="gbPullUrl" placeholder="rtsp://zlm/live/340200... or http://.../live.flv" /></label>
      </div>
      <div id="panelONVIF" class="soft-panel panel-hidden">
        <h3>ONVIF（明文用户名/密码）</h3>
        <div class="grid two">
          <label>Endpoint<input id="onvifEndpoint" placeholder="http://ip/onvif/device_service" /></label>
          <label>ProfileToken<input id="onvifProfileToken" placeholder="可选" /></label>
        </div>
        <div class="grid two">
          <label>用户名<input id="onvifUsername" placeholder="admin" /></label>
          <label>密码<input id="onvifPassword" type="text" placeholder="123456" /></label>
        </div>
        <label>绑定 RTSP URL<input id="onvifRtspUrl" placeholder="rtsp://user:pass@ip/stream" /></label>
      </div>
      <div id="panelUSB" class="soft-panel panel-hidden">
        <h3>USB 摄像头</h3>
        <div class="grid two">
          <label>设备名称<input id="usbName" placeholder="HD Pro Webcam C920 或 /dev/video0" /></label>
          <label>分辨率<input id="usbResolution" value="1280x720" /></label>
        </div>
        <label>帧率（fps）<input id="usbFramerate" type="number" value="30" /></label>
      </div>
      <label>高级模式 FFmpeg 命令（必须包含 {URL}）
        <textarea id="ffmpegCommand" rows="3" placeholder="ffmpeg ... -f flv {URL}"></textarea>
      </label>
      <div class="actions">
        <button id="btnFillAdvancedCmd">按输入类型填充推荐命令</button>
      </div>
      <p class="soft-note">提示：高级模式命令是“手动托管”，切换输入源不会自动强改你已编辑的命令；可点击上方按钮快速生成模板。</p>

      <div class="soft-panel">
        <h3>本地预览（调试画面，不会推到平台）</h3>
        <p class="soft-note">建议先在这里确认摄像头/地址有效，再点击“开始推流”。关闭预览会立即释放资源。</p>
        <div class="grid two">
          <label>预览宽度（px）
            <input id="previewWidth" type="number" value="960" min="240" max="1920" />
          </label>
          <label>预览帧率（fps）
            <input id="previewFps" type="number" value="10" min="1" max="20" />
          </label>
        </div>
        <div class="grid two">
          <label>Preview protocol
            <select id="previewMode">
              <option value="auto" selected>Auto (RTSP/ONVIF prefer WebRTC)</option>
              <option value="webrtc">WebRTC</option>
              <option value="mjpeg">MJPEG</option>
            </select>
          </label>
          <label>Note
            <input value="WebRTC is low-latency and usually lower bandwidth than MJPEG." readonly />
          </label>
        </div>
        <div class="actions">
          <button id="btnStartLocalPreview">开启本地预览</button>
          <button id="btnStopLocalPreview">关闭本地预览</button>
        </div>
        <div class="preview-panel">
          <img id="localPreviewImage" alt="推流本地预览画面" />
          <video id="localPreviewVideo" autoplay muted playsinline controls></video>
          <div id="localPreviewInfo" class="soft-note">本地预览默认关闭，点击“开启本地预览”后按当前配置拉流并显示。</div>
        </div>
      </div>

      <div class="soft-panel">
        <h3>拼屏推流（同一场直播多个摄像头）</h3>
        <div class="grid two">
          <label>启用拼屏
            <select id="multiInputEnabled">
              <option value="false" selected>关闭</option>
              <option value="true">开启</option>
            </select>
          </label>
          <label>布局模式
            <select id="multiInputLayout">
              <option value="canvas">画布自由排布（Canvas）</option>
              <option value="focus">主画面优先（Focus）</option>
              <option value="2x2">2x2</option>
              <option value="3x3">3x3</option>
              <option value="4x4">4x4</option>
              <option value="3x2">3x2</option>
            </select>
          </label>
        </div>
        <p class="soft-note">支持拖拽排序、每路标题叠加、主画面优先。至少 2 路源才能生效。</p>
        <div class="grid two">
          <label>从摄像头库添加（可多选）
            <select id="multiInputCameraPicker" multiple size="8"></select>
          </label>
          <div class="soft-panel">
            <h4>手动添加一条源</h4>
            <label>URL
              <input id="multiInputManualUrl" placeholder="rtsp:// / http:// / rtmp:// / 本地文件路径" />
            </label>
            <label>标题
              <input id="multiInputManualTitle" placeholder="例如：主机位 / 侧机位" />
            </label>
            <div class="actions">
              <button id="btnMultiInputAddManual">添加该源</button>
            </div>
          </div>
        </div>
        <div class="actions">
          <button id="btnMultiInputAddSelected">添加选中摄像头</button>
          <button id="btnMultiInputAutoLayout">自动网格排布</button>
          <button id="btnMultiInputClear">清空拼屏源</button>
        </div>
        <div class="soft-panel">
          <h4>画布编辑器（拖拽/缩放）</h4>
          <p class="soft-note">拖动画面块调整位置，拖动右下角圆点调整大小。双击画面块可设为主画面。</p>
          <div id="multiInputCanvas" class="mosaic-canvas"></div>
        </div>
        <div id="multiInputList" class="mosaic-list"></div>
      </div>
    </section>

    <section class="page-card">
      <h2>执行操作</h2>
      <h3>配置操作</h3>
      <div class="actions">
        <button id="load">读取配置</button>
        <button id="save" data-perm="operator,admin">保存配置</button>
      </div>
      <h3>推流控制</h3>
      <div class="actions">
        <button id="start" class="btn-success btn-lg" data-perm="operator,admin">开始推流</button>
        <button id="stop" class="btn-danger btn-lg" data-perm="operator,admin">停止推流</button>
        <button id="restart" class="btn-warning btn-lg" data-perm="operator,admin">重启推流</button>
        <button id="status">读取状态</button>
      </div>
      <div class="soft-note">状态每 5 秒自动刷新，你也可以手动点击“读取状态”。</div>
      <div class="actions">
        <button id="btnOpenAdvancedConsole" class="btn-ghost">打开高级控制台</button>
      </div>
      <pre id="box">{}</pre>
    </section>
  </main>

  <script src="/app/pages/shared.js"></script>
  <script>
    const { initPage, requestJSON, showJSON, bindAction, showToast, showConfirm, markFields, statusBadge, createPoller, setPanelVisible } = window.GoverShared;
    initPage({ active: "push" });

    const cameraMap = new Map();
    const videoMaterialMap = new Map();
    const audioMaterialMap = new Map();
    let pendingVideoMaterialId = "";
    let pendingAudioMaterialId = "";
    let localPreviewRunning = false;
    let localPreviewPeer = null;
    let localPreviewSessionId = "";
    let multiInputSources = [];

    function asText(id) {
      return String(document.getElementById(id).value || "").trim();
    }

    function asNumber(id, fallback) {
      const value = Number(document.getElementById(id).value || 0);
      return Number.isFinite(value) ? value : fallback;
    }

    function asBool(id) {
      return String(document.getElementById(id).value || "").toLowerCase() === "true";
    }

    function normalizeBitrateKbps(value) {
      const num = Number(value || 0);
      if (!Number.isFinite(num) || num <= 0) return 0;
      if (num > 120000) return 120000;
      return Math.round(num);
    }

    function syncBitrateCustomVisibility() {
      const preset = asText("bitratePreset");
      const wrap = document.getElementById("bitrateCustomWrap");
      wrap.style.display = preset === "custom" ? "" : "none";
    }

    function applyBitratePresetFromValue(value) {
      const normalized = normalizeBitrateKbps(value);
      const presetEl = document.getElementById("bitratePreset");
      const customEl = document.getElementById("bitrateCustom");
      if (!normalized) {
        presetEl.value = "auto";
      } else if (["2000", "3500", "5000", "8000", "12000"].includes(String(normalized))) {
        presetEl.value = String(normalized);
      } else {
        presetEl.value = "custom";
        customEl.value = String(normalized);
      }
      if (!customEl.value) {
        customEl.value = "4500";
      }
      syncBitrateCustomVisibility();
    }

    function currentBitrateKbps() {
      const preset = asText("bitratePreset");
      if (preset === "auto") return 0;
      if (preset === "custom") {
        return normalizeBitrateKbps(asNumber("bitrateCustom", 4500));
      }
      return normalizeBitrateKbps(preset);
    }

    function setPushStatusView(statusValue) {
      const status = Number(statusValue || 0);
      let text = "已停止";
      let type = "neutral";
      let detail = "推流进程当前未运行。";
      if (status === 3) {
        text = "运行中";
        type = "success";
        detail = "推流正常进行中。";
      } else if (status === 1) {
        text = "启动中";
        type = "warning";
        detail = "正在启动 FFmpeg 推流进程。";
      } else if (status === 4) {
        text = "重试中";
        type = "warning";
        detail = "推流失败后等待自动重试。";
      }
      const old = document.getElementById("pushStatusBadge");
      if (old) {
        old.outerHTML = statusBadge(text, type).replace("<span", '<span id="pushStatusBadge"');
      }
      document.getElementById("pushStatusText").textContent = detail;
    }

    function setLocalPreviewInfo(text) {
      document.getElementById("localPreviewInfo").textContent = text || "";
    }

    function stopLocalPreviewPeer() {
      if (localPreviewPeer) {
        try {
          localPreviewPeer.ontrack = null;
          localPreviewPeer.onconnectionstatechange = null;
          localPreviewPeer.close();
        } catch (_) {
          // Ignore close errors.
        }
      }
      localPreviewPeer = null;
      if (localPreviewSessionId) {
        requestJSON("/api/v1/push/preview/webrtc/close", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sessionId: localPreviewSessionId }),
        }).catch(() => {});
      }
      localPreviewSessionId = "";
    }

    function stopLocalPreview() {
      const img = document.getElementById("localPreviewImage");
      const video = document.getElementById("localPreviewVideo");
      localPreviewRunning = false;
      stopLocalPreviewPeer();
      img.style.display = "none";
      img.src = "";
      video.pause();
      video.style.display = "none";
      video.srcObject = null;
      setLocalPreviewInfo("Local preview stopped.");
    }

    function waitForICEGatheringComplete(peer) {
      if (!peer || peer.iceGatheringState === "complete") {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        const onState = () => {
          if (peer.iceGatheringState === "complete") {
            peer.removeEventListener("icegatheringstatechange", onState);
            resolve();
          }
        };
        peer.addEventListener("icegatheringstatechange", onState);
      });
    }

    function shouldUseWebRTCPreview() {
      const mode = asText("previewMode") || "auto";
      if (mode === "webrtc") return true;
      if (mode === "mjpeg") return false;
      const inputType = asText("inputType");
      if (inputType === "rtsp" || inputType === "onvif") return true;
      if (inputType === "gb28181") {
        const gb = asText("gbPullUrl").toLowerCase();
        return gb.startsWith("rtsp://") || gb.startsWith("rtsps://");
      }
      if (asBool("multiInputEnabled")) {
        return multiInputSources.some((item) => {
          const value = String((item && item.url) || "").trim().toLowerCase();
          return value.startsWith("rtsp://") || value.startsWith("rtsps://");
        });
      }
      return false;
    }

    async function startLocalPreviewWebRTC() {
      stopLocalPreviewPeer();
      const video = document.getElementById("localPreviewVideo");
      const img = document.getElementById("localPreviewImage");
      img.style.display = "none";
      img.src = "";

      const peer = new RTCPeerConnection({ iceServers: [] });
      try {
        localPreviewPeer = peer;
        const stream = new MediaStream();
        video.srcObject = stream;
        video.style.display = "block";
        localPreviewRunning = true;
        setLocalPreviewInfo("WebRTC preview connecting...");

        peer.ontrack = (event) => {
          const tracks = event.streams && event.streams[0] ? event.streams[0].getTracks() : [event.track];
          for (const track of tracks) {
            if (stream.getTracks().find((item) => item.id === track.id)) continue;
            stream.addTrack(track);
          }
        };

        peer.onconnectionstatechange = () => {
          if (!localPreviewRunning) return;
          const state = peer.connectionState;
          if (state === "connected") {
            setLocalPreviewInfo("WebRTC preview connected.");
          } else if (state === "failed" || state === "disconnected" || state === "closed") {
            setLocalPreviewInfo(`WebRTC preview connection: ${state}`);
          }
        };

        const offer = await peer.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: true });
        await peer.setLocalDescription(offer);
        await waitForICEGatheringComplete(peer);

        const local = peer.localDescription;
        if (!local || !local.sdp) {
          throw new Error("WebRTC local offer is empty");
        }
        const result = await requestJSON("/api/v1/push/preview/webrtc/offer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ type: local.type || "offer", sdp: local.sdp }),
        });
        const answer = result && result.data ? result.data : {};
        if (!answer.sdp) {
          throw new Error("WebRTC answer is empty");
        }
        await peer.setRemoteDescription({
          type: answer.type || "answer",
          sdp: answer.sdp,
        });
        localPreviewSessionId = String(answer.sessionId || "").trim();
        try {
          await video.play();
        } catch (_) {
          // Browser autoplay policy may block; keep controls visible for manual play.
        }
        setLocalPreviewInfo("WebRTC preview started.");
      } catch (error) {
        stopLocalPreview();
        throw error;
      }
    }

    function switchInputPanels() {

      const inputType = asText("inputType");
      setPanelVisible("panelVIDEO", inputType === "video");
      setPanelVisible("panelRTSP", inputType === "rtsp");
      setPanelVisible("panelMJPEG", inputType === "mjpeg");
      setPanelVisible("panelRTMP", inputType === "rtmp");
      setPanelVisible("panelGB28181", inputType === "gb28181");
      setPanelVisible("panelONVIF", inputType === "onvif");
      setPanelVisible("panelUSB", inputType === "usb_camera" || inputType === "usb_camera_plus");
    }

    function toMaterialRows(result) {
      const data = result && result.data ? result.data : {};
      if (Array.isArray(data.data)) return data.data;
      if (Array.isArray(data)) return data;
      return [];
    }

    function fillMaterialSelect(selectId, materialMap, rows, emptyText) {
      const select = document.getElementById(selectId);
      select.innerHTML = "";
      materialMap.clear();
      const base = document.createElement("option");
      base.value = "";
      base.textContent = emptyText;
      select.appendChild(base);
      for (const item of rows) {
        const id = Number(item && item.id ? item.id : 0);
        if (!id) continue;
        const key = String(id);
        materialMap.set(key, item);
        const option = document.createElement("option");
        option.value = key;
        const fileType = String(item.fileType || "").trim();
        const typeText = fileType ? `[${fileType}] ` : "";
        option.textContent = `${typeText}${item.name || `Material-${id}`}`;
        select.appendChild(option);
      }
    }

    function setPendingMaterialSelection(videoID, audioID) {
      pendingVideoMaterialId = videoID > 0 ? String(videoID) : "";
      pendingAudioMaterialId = audioID > 0 ? String(audioID) : "";
      applyPendingMaterialSelection();
    }

    function applyPendingMaterialSelection() {
      const videoSelect = document.getElementById("videoMaterialSelect");
      const audioSelect = document.getElementById("audioMaterialSelect");
      if (!pendingVideoMaterialId) {
        videoSelect.value = "";
      } else if (videoMaterialMap.has(pendingVideoMaterialId)) {
        videoSelect.value = pendingVideoMaterialId;
      }
      if (!pendingAudioMaterialId) {
        audioSelect.value = "";
      } else if (audioMaterialMap.has(pendingAudioMaterialId)) {
        audioSelect.value = pendingAudioMaterialId;
      }
      updateMaterialHint();
    }

    function updateMaterialHint() {
      const videoID = asText("videoMaterialSelect");
      const audioID = asText("audioMaterialSelect");
      const video = videoMaterialMap.get(videoID);
      const audio = audioMaterialMap.get(audioID);
      const parts = [];
      if (video) {
        parts.push(`视频：${video.name || `#${videoID}`} ${video.path || video.fullPath || ""}`.trim());
      }
      if (audio) {
        parts.push(`音频：${audio.name || `#${audioID}`} ${audio.path || audio.fullPath || ""}`.trim());
      }
      const hint = parts.length ? parts.join(" | ") : "请选择一个视频素材作为推流输入源。";
      document.getElementById("videoMaterialHint").textContent = hint;
    }

    async function loadMaterialSources() {
      const [videoResult, audioResult] = await Promise.all([
        requestJSON("/api/v1/materials?page=1&limit=200&fileType=1"),
        requestJSON("/api/v1/materials?page=1&limit=200&fileType=2"),
      ]);
      const videoRows = toMaterialRows(videoResult);
      const audioRows = toMaterialRows(audioResult);
      fillMaterialSelect("videoMaterialSelect", videoMaterialMap, videoRows, "（请选择视频素材）");
      fillMaterialSelect("audioMaterialSelect", audioMaterialMap, audioRows, "（不使用）");
      applyPendingMaterialSelection();
      const info = {
        code: 0,
        message: `素材加载完成：视频 ${videoRows.length} 条，音频 ${audioRows.length} 条`,
        data: {
          videoCount: videoRows.length,
          audioCount: audioRows.length,
        },
      };
      showJSON("box", info);
      return info;
    }

    function isUsbTemplateCommand(commandText) {
      const lower = String(commandText || "").toLowerCase();
      return lower.includes("-f dshow") || lower.includes("video=\"") || lower.includes("-f v4l2") || lower.includes("/dev/video");
    }

    function recommendedAdvancedCommand(inputType) {
      const type = String(inputType || "").toLowerCase();
      const commonOut = "-vcodec libx264 -pix_fmt yuv420p -r 25 -g 50 -b:v 3500k -maxrate 3500k -bufsize 7000k -preset veryfast -tune zerolatency -f flv {URL}";
      if (type === "rtsp" || type === "onvif") {
        return `ffmpeg -rtsp_transport tcp -i \"${type === "onvif" ? "rtsp://user:pass@ip/stream" : "rtsp://user:pass@ip/stream"}\" -an ${commonOut}`;
      }
      if (type === "mjpeg") {
        return "ffmpeg -f mjpeg -i \"http://ip:port/mjpeg\" -an " + commonOut;
      }
      if (type === "rtmp") {
        return "ffmpeg -i \"rtmp://ip/app/stream\" -an " + commonOut;
      }
      if (type === "gb28181") {
        return "ffmpeg -i \"rtsp://media-server/live/340200...\" -an " + commonOut;
      }
      if (type === "usb_camera" || type === "usb_camera_plus") {
        return "ffmpeg -f dshow -video_size 1280x720 -framerate 30 -i video=\"HD Pro Webcam C920\" -an " + commonOut;
      }
      return "ffmpeg -re -i \"input.mp4\" -an " + commonOut;
    }

    function autoSuggestAdvancedCommand() {
      const model = asNumber("model", 1);
      if (model !== 2) return;
      const inputType = asText("inputType");
      const commandEl = document.getElementById("ffmpegCommand");
      const current = commandEl.value || "";
      if (!current.trim()) {
        commandEl.value = recommendedAdvancedCommand(inputType);
        return;
      }
      const networkType = inputType === "rtsp" || inputType === "mjpeg" || inputType === "onvif" || inputType === "rtmp" || inputType === "gb28181";
      if (networkType && isUsbTemplateCommand(current)) {
        commandEl.value = recommendedAdvancedCommand(inputType);
      }
    }

    function cameraTypeLabel(type) {
      const value = String(type || "").toLowerCase();
      if (value === "rtsp") return "RTSP";
      if (value === "mjpeg") return "MJPEG";
      if (value === "rtmp") return "RTMP";
      if (value === "gb28181") return "GB28181";
      if (value === "onvif") return "ONVIF";
      if (value === "usb") return "USB";
      return value || "unknown";
    }

    function cameraHint(item) {
      if (!item) return "";
      const type = String(item.sourceType || "").toLowerCase();
      if (type === "rtsp" || type === "onvif") return item.rtspUrl || item.onvifEndpoint || "";
      if (type === "mjpeg") return item.mjpegUrl || "";
      if (type === "rtmp") return item.rtmpUrl || "";
      if (type === "gb28181") return item.gbPullUrl || item.gbDeviceId || "";
      if (type === "usb") return item.usbDeviceName || "";
      return "";
    }

    function cameraToMosaicSource(item) {
      if (!item) return null;
      const type = String(item.sourceType || "").toLowerCase();
      let url = "";
      if (type === "rtsp" || type === "onvif") {
        url = String(item.rtspUrl || "").trim();
      } else if (type === "mjpeg") {
        url = String(item.mjpegUrl || "").trim();
      } else if (type === "rtmp") {
        url = String(item.rtmpUrl || "").trim();
      } else if (type === "gb28181") {
        url = String(item.gbPullUrl || "").trim();
      }
      if (!url) {
        return null;
      }
      return {
        url,
        title: String(item.name || cameraTypeLabel(type) || "Source").trim(),
        primary: false,
        enableAudio: false,
        sourceType: type,
        materialId: 0,
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        z: 0,
      };
    }

    function normalizeMultiInputSource(item) {
      if (!item || typeof item !== "object") return null;
      const url = String(item.url || "").trim();
      if (!url) return null;
      return {
        url,
        title: String(item.title || "").trim(),
        primary: Boolean(item.primary),
        enableAudio: Boolean(item.enableAudio),
        sourceType: String(item.sourceType || "").trim(),
        materialId: Number(item.materialId || 0) || 0,
        x: Number(item.x || 0) || 0,
        y: Number(item.y || 0) || 0,
        w: Number(item.w || 0) || 0,
        h: Number(item.h || 0) || 0,
        z: Number(item.z || 0) || 0,
      };
    }

    function ensurePrimaryMultiInputSource(items) {
      if (!Array.isArray(items) || items.length === 0) return;
      let primaryIndex = items.findIndex((item) => Boolean(item && item.primary));
      if (primaryIndex < 0) primaryIndex = 0;
      for (let i = 0; i < items.length; i++) {
        items[i].primary = i === primaryIndex;
      }
    }

    function ensureSingleAudioSource(items) {
      if (!Array.isArray(items) || items.length === 0) return;
      let audioIndex = items.findIndex((item) => Boolean(item && item.enableAudio));
      if (audioIndex < 0) return;
      for (let i = 0; i < items.length; i++) {
        items[i].enableAudio = i === audioIndex;
      }
    }

    function clamp01(value) {
      const num = Number(value || 0);
      if (!Number.isFinite(num)) return 0;
      if (num < 0) return 0;
      if (num > 1) return 1;
      return num;
    }

    function autoLayoutMultiInput(items) {
      const list = Array.isArray(items) ? items : [];
      if (!list.length) return;
      const cols = Math.max(1, Math.ceil(Math.sqrt(list.length)));
      const rows = Math.max(1, Math.ceil(list.length / cols));
      const cellW = 1 / cols;
      const cellH = 1 / rows;
      const marginX = Math.min(0.01, cellW * 0.08);
      const marginY = Math.min(0.01, cellH * 0.08);
      for (let index = 0; index < list.length; index++) {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const item = list[index];
        item.x = clamp01(col * cellW + marginX);
        item.y = clamp01(row * cellH + marginY);
        item.w = clamp01(Math.max(0.08, cellW - marginX * 2));
        item.h = clamp01(Math.max(0.08, cellH - marginY * 2));
        item.z = index;
      }
    }

    function ensureCanvasLayout(items) {
      if (!Array.isArray(items) || !items.length) return;
      const hasAnyRect = items.some((item) => Number(item && item.w) > 0 || Number(item && item.h) > 0);
      if (!hasAnyRect) {
        autoLayoutMultiInput(items);
        return;
      }
      for (let index = 0; index < items.length; index++) {
        const item = items[index];
        const w = Number(item.w || 0);
        const h = Number(item.h || 0);
        item.w = w > 0 ? clamp01(Math.max(0.08, w)) : 0.24;
        item.h = h > 0 ? clamp01(Math.max(0.08, h)) : 0.24;
        item.x = clamp01(item.x || 0);
        item.y = clamp01(item.y || 0);
        if (item.x + item.w > 1) item.x = Math.max(0, 1 - item.w);
        if (item.y + item.h > 1) item.y = Math.max(0, 1 - item.h);
        item.z = Number.isFinite(Number(item.z)) ? Number(item.z) : index;
      }
      items.sort((a, b) => Number(a.z || 0) - Number(b.z || 0));
      for (let i = 0; i < items.length; i++) {
        items[i].z = i;
      }
    }

    function parseResolutionRatio() {
      const raw = asText("resolution") || "1280x720";
      const parts = raw.toLowerCase().split("x");
      if (parts.length !== 2) return { width: 16, height: 9 };
      const width = Number(parts[0] || 0);
      const height = Number(parts[1] || 0);
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        return { width: 16, height: 9 };
      }
      return { width, height };
    }

    function renderMultiInputCanvas() {
      const canvas = document.getElementById("multiInputCanvas");
      if (!canvas) return;
      const ratio = parseResolutionRatio();
      canvas.style.aspectRatio = `${ratio.width} / ${ratio.height}`;
      canvas.innerHTML = "";
      if (!multiInputSources.length) return;
      ensureCanvasLayout(multiInputSources);

      const startDrag = (index, mode, downEvent) => {
        const rect = canvas.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        const target = multiInputSources[index];
        if (!target) return;
        const start = {
          x: target.x,
          y: target.y,
          w: target.w,
          h: target.h,
          clientX: downEvent.clientX,
          clientY: downEvent.clientY,
        };
        const move = (moveEvent) => {
          const dx = (moveEvent.clientX - start.clientX) / rect.width;
          const dy = (moveEvent.clientY - start.clientY) / rect.height;
          if (mode === "move") {
            target.x = clamp01(start.x + dx);
            target.y = clamp01(start.y + dy);
            if (target.x + target.w > 1) target.x = 1 - target.w;
            if (target.y + target.h > 1) target.y = 1 - target.h;
          } else {
            target.w = clamp01(Math.max(0.08, start.w + dx));
            target.h = clamp01(Math.max(0.08, start.h + dy));
            if (target.x + target.w > 1) target.w = 1 - target.x;
            if (target.y + target.h > 1) target.h = 1 - target.y;
          }
          renderMultiInputCanvas();
        };
        const up = () => {
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", up);
          renderMultiInputList();
        };
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);
      };

      multiInputSources.forEach((item, index) => {
        const node = document.createElement("div");
        node.className = `mosaic-canvas-item${item.primary ? " primary" : ""}`;
        node.style.left = `${(item.x * 100).toFixed(4)}%`;
        node.style.top = `${(item.y * 100).toFixed(4)}%`;
        node.style.width = `${(item.w * 100).toFixed(4)}%`;
        node.style.height = `${(item.h * 100).toFixed(4)}%`;
        node.style.zIndex = String(index + 10);

        const head = document.createElement("div");
        head.className = "mosaic-canvas-head";
        head.innerHTML = `<span class="mosaic-canvas-label">${item.title || `Source-${index + 1}`}</span><span>#${index + 1}</span>`;
        head.onmousedown = (event) => {
          event.preventDefault();
          document.getElementById("multiInputLayout").value = "canvas";
          startDrag(index, "move", event);
        };
        head.ondblclick = (event) => {
          event.preventDefault();
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].primary = i === index;
          }
          renderMultiInputList();
          renderMultiInputCanvas();
        };

        const body = document.createElement("div");
        body.className = "mosaic-canvas-body";
        body.textContent = item.url || "";

        const handle = document.createElement("div");
        handle.className = "mosaic-canvas-handle";
        handle.onmousedown = (event) => {
          event.preventDefault();
          document.getElementById("multiInputLayout").value = "canvas";
          startDrag(index, "resize", event);
        };

        node.appendChild(head);
        node.appendChild(body);
        node.appendChild(handle);
        canvas.appendChild(node);
      });
    }

    function mergeAndSetMultiInputSources(items) {
      const next = [];
      const seen = new Set();
      for (const raw of items || []) {
        const normalized = normalizeMultiInputSource(raw);
        if (!normalized) continue;
        if (seen.has(normalized.url)) continue;
        seen.add(normalized.url);
        next.push(normalized);
      }
      ensurePrimaryMultiInputSource(next);
      ensureSingleAudioSource(next);
      ensureCanvasLayout(next);
      multiInputSources = next;
      document.getElementById("sourceAudioEnabled").value = next.some((item) => item.enableAudio) ? "true" : "false";
      renderMultiInputList();
      renderMultiInputCanvas();
    }

    function renderMultiInputList() {
      const container = document.getElementById("multiInputList");
      if (!container) return;
      container.innerHTML = "";
      if (!multiInputSources.length) {
        container.innerHTML = '<div class="mosaic-item-empty">当前没有拼屏源。可从“摄像头库多选”添加，或手动添加 URL。</div>';
        return;
      }
      multiInputSources.forEach((item, index) => {
        const row = document.createElement("div");
        row.className = "mosaic-item";
        row.draggable = true;
        row.dataset.index = String(index);

        row.addEventListener("dragstart", (event) => {
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", String(index));
        });
        row.addEventListener("dragover", (event) => {
          event.preventDefault();
          row.classList.add("drag-over");
          event.dataTransfer.dropEffect = "move";
        });
        row.addEventListener("dragleave", () => {
          row.classList.remove("drag-over");
        });
        row.addEventListener("drop", (event) => {
          event.preventDefault();
          row.classList.remove("drag-over");
          const from = Number(event.dataTransfer.getData("text/plain"));
          const to = index;
          if (!Number.isFinite(from) || from < 0 || from >= multiInputSources.length || from === to) return;
          const moved = multiInputSources.splice(from, 1)[0];
          multiInputSources.splice(to, 0, moved);
          ensurePrimaryMultiInputSource(multiInputSources);
          ensureSingleAudioSource(multiInputSources);
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].z = i;
          }
          renderMultiInputList();
          renderMultiInputCanvas();
        });

        const head = document.createElement("div");
        head.className = "mosaic-item-head";

        const handle = document.createElement("span");
        handle.className = "mosaic-item-handle";
        handle.textContent = "↕";
        head.appendChild(handle);

        const titleInput = document.createElement("input");
        titleInput.className = "mosaic-item-title";
        titleInput.value = item.title || "";
        titleInput.placeholder = `来源 ${index + 1} 标题`;
        titleInput.onchange = () => {
          multiInputSources[index].title = String(titleInput.value || "").trim();
          renderMultiInputCanvas();
        };
        head.appendChild(titleInput);

        const primaryBtn = document.createElement("button");
        primaryBtn.type = "button";
        primaryBtn.className = item.primary ? "btn-success btn-mini" : "btn-ghost btn-mini";
        primaryBtn.textContent = item.primary ? "主画面" : "设为主画面";
        primaryBtn.onclick = () => {
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].primary = i === index;
          }
          renderMultiInputList();
          renderMultiInputCanvas();
        };
        head.appendChild(primaryBtn);

        const audioBtn = document.createElement("button");
        audioBtn.type = "button";
        audioBtn.className = item.enableAudio ? "btn-warning btn-mini" : "btn-ghost btn-mini";
        audioBtn.textContent = item.enableAudio ? "声音:开" : "声音:关";
        audioBtn.onclick = () => {
          const nextState = !multiInputSources[index].enableAudio;
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].enableAudio = false;
          }
          multiInputSources[index].enableAudio = nextState;
          document.getElementById("sourceAudioEnabled").value = nextState ? "true" : "false";
          renderMultiInputList();
        };
        head.appendChild(audioBtn);

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "btn-danger btn-mini";
        removeBtn.textContent = "移除";
        removeBtn.onclick = () => {
          multiInputSources.splice(index, 1);
          ensurePrimaryMultiInputSource(multiInputSources);
          ensureSingleAudioSource(multiInputSources);
          document.getElementById("sourceAudioEnabled").value = multiInputSources.some((item) => item.enableAudio) ? "true" : "false";
          ensureCanvasLayout(multiInputSources);
          renderMultiInputList();
          renderMultiInputCanvas();
        };
        head.appendChild(removeBtn);

        const urlInput = document.createElement("input");
        urlInput.value = item.url || "";
        urlInput.placeholder = "URL";
        urlInput.onchange = () => {
          multiInputSources[index].url = String(urlInput.value || "").trim();
          renderMultiInputCanvas();
        };

        const info = document.createElement("div");
        info.className = "mosaic-item-url";
        info.textContent = `类型：${item.sourceType || "custom"} ｜ 拖拽可调整布局顺序`;

        row.appendChild(head);
        row.appendChild(urlInput);
        row.appendChild(info);
        container.appendChild(row);
      });
    }

    function collectMultiInputSourcesForPayload() {
      ensureCanvasLayout(multiInputSources);
      const normalized = [];
      const seen = new Set();
      for (const item of multiInputSources) {
        const source = normalizeMultiInputSource(item);
        if (!source) continue;
        if (seen.has(source.url)) continue;
        seen.add(source.url);
        source.x = clamp01(source.x);
        source.y = clamp01(source.y);
        source.w = clamp01(Math.max(0.08, source.w || 0));
        source.h = clamp01(Math.max(0.08, source.h || 0));
        source.z = normalized.length;
        normalized.push(source);
      }
      ensurePrimaryMultiInputSource(normalized);
      ensureSingleAudioSource(normalized);
      multiInputSources = normalized;
      return normalized;
    }

    function fillMultiInputCameraPicker(items) {
      const picker = document.getElementById("multiInputCameraPicker");
      if (!picker) return;
      picker.innerHTML = "";
      for (const item of items || []) {
        const source = cameraToMosaicSource(item);
        if (!source) continue;
        const option = document.createElement("option");
        option.value = String(item.id);
        option.textContent = `${item.name || `Camera-${item.id}`} [${cameraTypeLabel(item.sourceType)}]`;
        picker.appendChild(option);
      }
    }

    function addSelectedCamerasToMultiInput() {
      const picker = document.getElementById("multiInputCameraPicker");
      if (!picker) return { added: 0, skipped: 0 };
      const selected = Array.from(picker.selectedOptions || []);
      if (!selected.length) throw new Error("请先在摄像头库里选择至少一项");

      let added = 0;
      let skipped = 0;
      const existing = new Set(multiInputSources.map((item) => item.url));
      for (const option of selected) {
        const id = Number(option.value || 0);
        const camera = cameraMap.get(id);
        const source = cameraToMosaicSource(camera);
        if (!source || existing.has(source.url)) {
          skipped++;
          continue;
        }
        existing.add(source.url);
        multiInputSources.push(source);
        added++;
      }
      ensurePrimaryMultiInputSource(multiInputSources);
      ensureSingleAudioSource(multiInputSources);
      ensureCanvasLayout(multiInputSources);
      renderMultiInputList();
      renderMultiInputCanvas();
      return { added, skipped };
    }

    function addManualMultiInputSource() {
      const url = String(document.getElementById("multiInputManualUrl").value || "").trim();
      const title = String(document.getElementById("multiInputManualTitle").value || "").trim();
      if (!url) throw new Error("请先输入拼屏源 URL");
      if (multiInputSources.some((item) => item.url === url)) {
        throw new Error("该 URL 已经在拼屏列表中");
      }
      const sourceType = url.startsWith("rtsp://") ? "rtsp"
        : (url.includes(".mjpg") || url.includes("mjpeg")) ? "mjpeg"
        : url.startsWith("rtmp://") ? "rtmp"
        : "custom";
      multiInputSources.push({
        url,
        title: title || `Source-${multiInputSources.length + 1}`,
        primary: false,
        enableAudio: false,
        sourceType,
        materialId: 0,
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        z: multiInputSources.length,
      });
      ensurePrimaryMultiInputSource(multiInputSources);
      ensureSingleAudioSource(multiInputSources);
      ensureCanvasLayout(multiInputSources);
      renderMultiInputList();
      renderMultiInputCanvas();
      document.getElementById("multiInputManualUrl").value = "";
      document.getElementById("multiInputManualTitle").value = "";
    }

    function fillByCamera(item) {
      if (!item) return;
      const type = String(item.sourceType || "").toLowerCase();
      if (type === "rtsp") {
        document.getElementById("inputType").value = "rtsp";
        document.getElementById("rtspUrl").value = item.rtspUrl || "";
      } else if (type === "mjpeg") {
        document.getElementById("inputType").value = "mjpeg";
        document.getElementById("mjpegUrl").value = item.mjpegUrl || "";
      } else if (type === "rtmp") {
        document.getElementById("inputType").value = "rtmp";
        document.getElementById("rtmpUrl").value = item.rtmpUrl || "";
      } else if (type === "gb28181") {
        document.getElementById("inputType").value = "gb28181";
        document.getElementById("gbPullUrl").value = item.gbPullUrl || "";
      } else if (type === "onvif") {
        document.getElementById("inputType").value = "onvif";
        document.getElementById("onvifEndpoint").value = item.onvifEndpoint || "";
        document.getElementById("onvifUsername").value = item.onvifUsername || "";
        document.getElementById("onvifPassword").value = item.onvifPassword || "";
        document.getElementById("onvifProfileToken").value = item.onvifProfileToken || "";
        document.getElementById("onvifRtspUrl").value = item.rtspUrl || "";
      } else if (type === "usb") {
        document.getElementById("inputType").value = "usb_camera";
        document.getElementById("usbName").value = item.usbDeviceName || "";
        document.getElementById("usbResolution").value = item.usbDeviceResolution || "1280x720";
        document.getElementById("usbFramerate").value = String(item.usbDeviceFramerate || 30);
      }
      switchInputPanels();
    }

    async function loadCameras() {
      const params = new URLSearchParams();
      params.set("page", "1");
      params.set("limit", "200");
      const filterType = asText("cameraFilterType");
      if (filterType) params.set("sourceType", filterType);
      const result = await requestJSON(`/api/v1/cameras?${params.toString()}`);
      showJSON("box", result);
      const select = document.getElementById("cameraSelect");
      select.innerHTML = '<option value="">（请选择已保存摄像头）</option>';
      cameraMap.clear();
      const items = ((result || {}).data || {}).data || [];
      for (const item of items) {
        cameraMap.set(item.id, item);
        const option = document.createElement("option");
        option.value = String(item.id);
        option.textContent = `${item.name || `Camera-${item.id}`} [${cameraTypeLabel(item.sourceType)}] ${cameraHint(item)}`;
        select.appendChild(option);
      }
      fillMultiInputCameraPicker(items);
    }

    async function applySelectedCamera() {
      const id = Number(document.getElementById("cameraSelect").value || 0);
      if (!id) throw new Error("请先选择摄像头");
      const result = await requestJSON(`/api/v1/cameras/${id}/apply-push`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: "{}"
      });
      showJSON("box", result);
      if (result && result.data && result.data.pushSetting) {
        fillSetting(result.data.pushSetting);
        markFields([
          "inputType",
          "rtspUrl",
          "mjpegUrl",
          "rtmpUrl",
          "gbPullUrl",
          "onvifEndpoint",
          "onvifUsername",
          "onvifPassword",
          "onvifProfileToken",
          "onvifRtspUrl",
          "usbName",
          "usbResolution",
          "usbFramerate",
        ]);
        showToast("摄像头已套用到推流配置", "success");
      }
    }

    function fillSetting(item) {
      const data = item || {};
      document.getElementById("model").value = String(data.model || 1);
      document.getElementById("inputType").value = data.inputType || "video";
      document.getElementById("resolution").value = data.outputResolution || "1280x720";
      document.getElementById("quality").value = String(data.outputQuality || 2);
      applyBitratePresetFromValue(data.outputBitrateKbps || 0);
      document.getElementById("autoRetry").value = data.isAutoRetry ? "true" : "false";
      document.getElementById("retryInterval").value = String(data.retryInterval || 30);
      document.getElementById("sourceAudioEnabled").value = data.isMute ? "false" : "true";
      document.getElementById("ffmpegCommand").value = data.ffmpegCommand || "";
      document.getElementById("rtspUrl").value = data.rtspUrl || "";
      document.getElementById("mjpegUrl").value = data.mjpegUrl || "";
      document.getElementById("rtmpUrl").value = data.rtmpUrl || "";
      document.getElementById("gbPullUrl").value = data.gbPullUrl || "";
      document.getElementById("onvifEndpoint").value = data.onvifEndpoint || "";
      document.getElementById("onvifUsername").value = data.onvifUsername || "";
      document.getElementById("onvifPassword").value = data.onvifPassword || "";
      document.getElementById("onvifProfileToken").value = data.onvifProfileToken || "";
      document.getElementById("onvifRtspUrl").value = data.rtspUrl || "";
      document.getElementById("usbName").value = data.inputDeviceName || "";
      document.getElementById("usbResolution").value = data.inputDeviceResolution || "1280x720";
      document.getElementById("usbFramerate").value = String(data.inputDeviceFramerate || 30);
      setPendingMaterialSelection(Number(data.videoId || 0), Number(data.audioId || 0));
      document.getElementById("multiInputEnabled").value = data.multiInputEnabled ? "true" : "false";
      document.getElementById("multiInputLayout").value = data.multiInputLayout || "2x2";
      const fromMeta = Array.isArray(data.multiInputMeta) ? data.multiInputMeta : [];
      const fromURL = Array.isArray(data.multiInputUrls) ? data.multiInputUrls.map((url) => ({ url })) : [];
      mergeAndSetMultiInputSources(fromMeta.length ? fromMeta : fromURL);
      if (data.multiInputEnabled) {
        const hasAudioSource = multiInputSources.some((item) => item.enableAudio);
        document.getElementById("sourceAudioEnabled").value = hasAudioSource ? "true" : "false";
      }
      switchInputPanels();
      autoSuggestAdvancedCommand();
    }

    async function loadSetting() {
      const result = await requestJSON("/api/v1/push/setting");
      fillSetting(result.data || {});
      showJSON("box", result);
      await refreshPushStatus(true);
    }

    function buildPayload() {
      const inputType = asText("inputType") || "video";
      const videoId = Number(asText("videoMaterialSelect") || 0);
      const audioId = Number(asText("audioMaterialSelect") || 0);
      const multiInputEnabled = asBool("multiInputEnabled");
      const multiInputLayout = asText("multiInputLayout") || "2x2";
      const multiSources = collectMultiInputSourcesForPayload();
      if (multiInputEnabled && multiSources.length < 2) {
        throw new Error("启用拼屏时至少需要 2 路有效输入源");
      }
      if (inputType === "video" && videoId <= 0) {
        throw new Error("please select a video material source before saving");
      }
      const sourceAudioEnabled = asBool("sourceAudioEnabled");
      const hasMultiAudioSource = multiSources.some((item) => Boolean(item.enableAudio));
      const muteAll = multiInputEnabled ? !hasMultiAudioSource : !sourceAudioEnabled;
      const payload = {
        model: asNumber("model", 1),
        inputType,
        videoId,
        audioId,
        outputResolution: asText("resolution") || "1280x720",
        outputQuality: asNumber("quality", 2),
        outputBitrateKbps: currentBitrateKbps(),
        isAutoRetry: asBool("autoRetry"),
        retryInterval: asNumber("retryInterval", 30),
        isMute: muteAll,
        ffmpegCommand: document.getElementById("ffmpegCommand").value || "",
        rtspUrl: asText("rtspUrl"),
        mjpegUrl: asText("mjpegUrl"),
        rtmpUrl: asText("rtmpUrl"),
        gbPullUrl: asText("gbPullUrl"),
        onvifEndpoint: asText("onvifEndpoint"),
        onvifUsername: asText("onvifUsername"),
        onvifPassword: document.getElementById("onvifPassword").value || "",
        onvifProfileToken: asText("onvifProfileToken"),
        inputDeviceName: asText("usbName"),
        inputDeviceResolution: asText("usbResolution"),
        inputDeviceFramerate: asNumber("usbFramerate", 30),
        multiInputEnabled,
        multiInputLayout,
        multiInputMeta: multiSources,
        multiInputUrls: multiSources.map((item) => item.url),
      };
      if (inputType === "onvif") {
        payload.rtspUrl = asText("onvifRtspUrl");
      }
      return payload;
    }

    async function saveSetting() {
      const result = await requestJSON("/api/v1/push/setting", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(buildPayload())
      });
      showJSON("box", result);
    }

    async function startLocalPreview() {
      const saveResult = await requestJSON("/api/v1/push/setting", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(buildPayload())
      });
      showJSON("box", saveResult);
      if (saveResult && Number(saveResult.code) < 0) {
        throw new Error(saveResult.message || "save push setting failed, preview not started");
      }

      const previewMode = asText("previewMode") || "auto";
      if (shouldUseWebRTCPreview()) {
        try {
          await startLocalPreviewWebRTC();
          return;
        } catch (error) {
          if (previewMode === "webrtc") {
            throw error;
          }
          showToast(`WebRTC preview failed, fallback to MJPEG: ${error.message || String(error)}`, "info");
        }
      }

      const width = Math.max(240, Math.min(1920, asNumber("previewWidth", 960)));
      const fps = Math.max(1, Math.min(20, asNumber("previewFps", 10)));
      const img = document.getElementById("localPreviewImage");
      const video = document.getElementById("localPreviewVideo");
      localPreviewRunning = true;
      stopLocalPreviewPeer();
      video.pause();
      video.style.display = "none";
      video.srcObject = null;
      img.style.display = "block";
      img.onerror = () => {
        if (!localPreviewRunning) return;
        setLocalPreviewInfo("Local MJPEG preview failed. Please re-check source settings.");
      };
      img.onload = () => {
        if (!localPreviewRunning) return;
        setLocalPreviewInfo("Local MJPEG preview running.");
      };
      img.src = `/api/v1/push/preview/mjpeg?width=${width}&fps=${fps}&_ts=${Date.now()}`;
      setLocalPreviewInfo("Connecting MJPEG preview...");
    }

    async function refreshPushStatus(quiet) {
      const result = await requestJSON("/api/v1/push/status");
      if (!quiet) {
        showJSON("box", result);
      }
      setPushStatusView(result && result.data ? result.data.status : 0);
      return result;
    }

    document.getElementById("inputType").onchange = () => {
      switchInputPanels();
      autoSuggestAdvancedCommand();
    };
    document.getElementById("videoMaterialSelect").onchange = updateMaterialHint;
    document.getElementById("audioMaterialSelect").onchange = updateMaterialHint;
    document.getElementById("model").onchange = autoSuggestAdvancedCommand;
    document.getElementById("resolution").onchange = () => {
      renderMultiInputCanvas();
    };
    document.getElementById("bitratePreset").onchange = syncBitrateCustomVisibility;
    document.getElementById("cameraFilterType").onchange = () => loadCameras().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    document.getElementById("multiInputEnabled").onchange = () => {
      if (!asBool("multiInputEnabled")) {
        showToast("已关闭拼屏，推流将按单路输入源配置运行", "info");
      } else if (!multiInputSources.some((item) => item.enableAudio)) {
        document.getElementById("sourceAudioEnabled").value = "false";
      }
    };
    document.getElementById("sourceAudioEnabled").onchange = () => {
      if (!asBool("multiInputEnabled")) return;
      const enable = asBool("sourceAudioEnabled");
      if (!enable) {
        for (const item of multiInputSources) {
          item.enableAudio = false;
        }
      } else if (multiInputSources.length > 0 && !multiInputSources.some((item) => item.enableAudio)) {
        multiInputSources[0].enableAudio = true;
      }
      renderMultiInputList();
    };

    bindAction("load", loadSetting, "box", { successToast: false });
    bindAction("save", saveSetting, "box");
    bindAction("start", async () => {
      const result = await requestJSON("/api/v1/push/start", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
      showJSON("box", result);
      await refreshPushStatus(true);
      return result;
    }, "box");
    bindAction("stop", async () => {
      const result = await requestJSON("/api/v1/push/stop", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
      showJSON("box", result);
      await refreshPushStatus(true);
      return result;
    }, "box");
    bindAction("restart", async () => {
      const result = await requestJSON("/api/v1/push/restart", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
      showJSON("box", result);
      await refreshPushStatus(true);
      return result;
    }, "box");
    bindAction("status", () => refreshPushStatus(false), "box", { successToast: false });
    bindAction("btnLoadCameras", loadCameras, "box", { successToast: false });
    bindAction("btnApplyCamera", applySelectedCamera, "box");
    bindAction("btnLoadMaterialSources", loadMaterialSources, "box", { successToast: false });
    bindAction("btnOpenCameraPage", async () => {
      window.location.href = "/app/pages/cameras.html";
    }, "box");
    bindAction("btnFillAdvancedCmd", async () => {
      document.getElementById("ffmpegCommand").value = recommendedAdvancedCommand(asText("inputType"));
      showJSON("box", { code: 0, message: "已按当前输入类型填充推荐高级命令" });
    }, "box");
    bindAction("btnStartLocalPreview", startLocalPreview, "box");
    bindAction("btnStopLocalPreview", async () => {
      stopLocalPreview();
      showJSON("box", { code: 0, message: "已关闭本地预览" });
    }, "box");
    bindAction("btnMultiInputAddSelected", async () => {
      const result = addSelectedCamerasToMultiInput();
      if (!result.added && result.skipped) {
        throw new Error("所选摄像头未能添加（可能缺少可拉流地址或已存在）");
      }
      showJSON("box", { code: 0, message: `拼屏源新增 ${result.added} 路，跳过 ${result.skipped} 路` });
      return { code: 0, message: `已添加 ${result.added} 路` };
    }, "box");
    bindAction("btnMultiInputAddManual", async () => {
      addManualMultiInputSource();
      showJSON("box", { code: 0, message: "manual mosaic source added" });
      return { code: 0, message: "manual mosaic source added" };
    }, "box");
    bindAction("btnMultiInputAutoLayout", async () => {
      if (!multiInputSources.length) {
        throw new Error("no mosaic source to layout");
      }
      autoLayoutMultiInput(multiInputSources);
      document.getElementById("multiInputLayout").value = "canvas";
      renderMultiInputList();
      renderMultiInputCanvas();
      showJSON("box", { code: 0, message: "auto layout finished and switched to canvas" });
      return { code: 0, message: "auto layout finished" };
    }, "box");
    bindAction("btnMultiInputClear", async () => {
      const ok = await showConfirm("clear mosaic", "clear all mosaic sources?");
      if (!ok) {
        return { code: 0, message: "cancelled" };
      }
      multiInputSources = [];
      document.getElementById("sourceAudioEnabled").value = "false";
      renderMultiInputList();
      renderMultiInputCanvas();
      showJSON("box", { code: 0, message: "mosaic sources cleared" });
      return { code: 0, message: "mosaic sources cleared" };
    }, "box");
    bindAction("btnOpenAdvancedConsole", async () => {
      window.open("/app/index.html", "_blank", "noopener");
      return { code: 0, message: "已打开高级控制台" };
    }, "box");

    window.addEventListener("beforeunload", () => {
      stopLocalPreviewPeer();
    });

    switchInputPanels();
    applyBitratePresetFromValue(0);
    renderMultiInputList();
    renderMultiInputCanvas();
    stopLocalPreview();
    loadSetting().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    loadCameras().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    loadMaterialSources().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    const statusPoller = createPoller(() => refreshPushStatus(true), 5000);
    statusPoller.start();
  </script>
</body>
</html>
