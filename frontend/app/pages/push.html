<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>推流配置</title>
  <link rel="stylesheet" href="/app/pages/shared.css" />
</head>
<body>
  <header class="shared-header">
    <div id="sharedNav"></div>
  </header>
  <main class="page-shell">
    <section class="page-card">
      <h1>推流配置</h1>
      <p class="soft-note">推荐流程：先在摄像头管理页保存设备，然后在这里一键套用，减少手动输入错误。</p>
      <div id="roleTip" class="role-tip"></div>
      <div class="status-line">
        <strong>当前推流状态:</strong>
        <span id="pushStatusBadge" class="badge badge-neutral">检查中</span>
        <span id="pushStatusText" class="soft-note">系统正在读取最新状态...</span>
      </div>
    </section>

    <section class="page-card">
      <h2>快速套用（来自摄像头库）</h2>
      <div class="grid two">
        <label>类型筛选
          <select id="cameraFilterType">
            <option value="">全部</option>
            <option value="rtsp">RTSP</option>
            <option value="mjpeg">MJPEG</option>
            <option value="rtmp">RTMP</option>
            <option value="gb28181">GB28181</option>
            <option value="onvif">ONVIF</option>
            <option value="usb">USB</option>
          </select>
        </label>
        <label>选择摄像头
          <select id="cameraSelect">
            <option value="">（请先刷新列表）</option>
          </select>
        </label>
      </div>
      <div class="actions">
        <button id="btnLoadCameras">刷新摄像头列表</button>
        <button id="btnApplyCamera">一键套用并保存</button>
        <button id="btnOpenCameraPage">打开摄像头管理页</button>
      </div>
    </section>

    <section class="page-card">
      <h2>FFmpeg 检测与安装</h2>
      <div class="grid two">
        <label>FFmpeg 路径（可手动输入）
          <input id="pushFFmpegPathInput" placeholder="Windows 示例: C:\path\to\ffmpeg.exe 或 C:\path\to\目录；Linux 示例: /opt/ffmpeg/ffmpeg 或 /opt/ffmpeg" />
        </label>
        <label>CDN 加速预设
          <select id="pushFFmpegCdnPreset">
            <option value="__auto__" selected>自动（测速后选择最快）</option>
            <option value="">不使用（直连 GitHub）</option>
            <option value="https://gh-proxy.org/">gh-proxy.org</option>
            <option value="https://hk.gh-proxy.org/">hk.gh-proxy.org</option>
            <option value="https://gitproxy.click/">gitproxy.click</option>
            <option value="__custom__">自定义</option>
          </select>
        </label>
      </div>
      <div id="pushFFmpegCdnCustomWrap" class="panel-hidden">
        <label>自定义 CDN 前缀
          <input id="pushFFmpegCdnCustom" placeholder="例如：https://gh-proxy.org/" />
        </label>
      </div>
      <div class="actions">
        <button id="btnAutoDetectFFmpegPush">扫描并自动保存 FFmpeg 路径</button>
        <button id="btnInstallFFmpegPush">自动下载并安装 FFmpeg</button>
        <button id="btnSaveFFmpegPathPush">保存手动输入的 FFmpeg 路径</button>
      </div>
      <div class="upload-progress">
        <div class="progress-bar"><span id="pushFFmpegProgressValue" class="progress-value"></span></div>
        <div id="pushFFmpegProgressText" class="soft-note">等待执行 FFmpeg 检测或安装任务</div>
        <div id="pushFFmpegTaskId" class="soft-note">当前安装任务 ID：-</div>
        <div id="pushFFmpegRouteLabel" class="soft-note">本次下载线路：-</div>
        <div id="pushFFmpegStageList" class="ffmpeg-stage-list">
          <span class="badge badge-neutral" data-stage="detect">检测</span>
          <span class="badge badge-neutral" data-stage="download">下载</span>
          <span class="badge badge-neutral" data-stage="extract">解压</span>
          <span class="badge badge-neutral" data-stage="verify">校验</span>
          <span class="badge badge-neutral" data-stage="save">保存</span>
        </div>
      </div>
      <p class="soft-note">自动扫描会保存并回填；扫描不到时可手动输入并保存，也可自动下载安装到 data 目录（压缩包会自动清理）。</p>
    </section>

    <section class="page-card">
      <h2>基础推流参数</h2>
      <div class="grid two">
        <label>模式
          <select id="model">
            <option value="1">普通模式</option>
            <option value="2">高级模式</option>
          </select>
        </label>
        <label>输入类型
          <select id="inputType">
            <option value="video">视频文件</option>
            <option value="usb_camera">USB 摄像头</option>
            <option value="desktop">桌面</option>
            <option value="rtsp">RTSP</option>
            <option value="mjpeg">MJPEG</option>
            <option value="rtmp">RTMP</option>
            <option value="gb28181">GB28181</option>
            <option value="onvif">ONVIF</option>
          </select>
        </label>
      </div>
      <div class="grid two">
        <label>输出分辨率<input id="resolution" value="1280x720" /></label>
        <label>输出质量
          <select id="quality">
            <option value="1">高</option>
            <option value="2" selected>中</option>
            <option value="3">低</option>
            <option value="9">原画</option>
          </select>
        </label>
      </div>
      <div class="grid two">
        <label>推流码率预设
          <select id="bitratePreset">
            <option value="auto" selected>自动（跟随质量档位）</option>
            <option value="2000">流畅 2M - 适合手机观看</option>
            <option value="3500">标准 3.5M - 日常推荐</option>
            <option value="5000">高清 5M - 画质优先</option>
            <option value="8000">超清 8M - 高速网络</option>
            <option value="12000">蓝光 12M - 极高画质</option>
            <option value="custom">自定义</option>
          </select>
        </label>
        <label id="bitrateCustomWrap" style="display:none;">自定义码率（kbps）
          <input id="bitrateCustom" type="number" value="4500" min="500" max="120000" />
        </label>
      </div>
      <p class="soft-note">建议先用 3500~5000 kbps；网络不稳时可降到 2000 kbps，避免观众端缓冲卡顿。</p>
      <div class="grid two">
        <label>自动重试
          <select id="autoRetry">
            <option value="true" selected>开启</option>
            <option value="false">关闭</option>
          </select>
        </label>
        <label>重试间隔（秒）<input id="retryInterval" type="number" value="30" /></label>
      </div>
      <div class="grid two">
        <label>输入源声音
          <select id="sourceAudioEnabled">
            <option value="false" selected>关闭（默认）</option>
            <option value="true">开启</option>
          </select>
        </label>
        <label>说明
          <input value="单路推流可直接开关；多路拼屏可在下方为某一路单独打开声音。" readonly />
        </label>
      </div>
    </section>

    <section class="page-card">
      <h2>输入源详情</h2>
      <div id="panelVIDEO" class="soft-panel panel-hidden">
        <h3>视频素材</h3>
        <div class="grid two">
          <label>视频素材
            <select id="videoMaterialSelect">
              <option value="">（请先刷新素材）</option>
            </select>
          </label>
          <label>背景音频（可选）
            <select id="audioMaterialSelect">
              <option value="">（不使用）</option>
            </select>
          </label>
        </div>
        <div class="actions">
          <button id="btnLoadMaterialSources">刷新素材列表</button>
        </div>
        <div id="videoMaterialHint" class="soft-note">请选择一个视频素材作为推流输入源。</div>
      </div>
      <div id="panelRTSP" class="soft-panel panel-hidden">
        <h3>RTSP</h3>
        <label>RTSP URL<input id="rtspUrl" placeholder="rtsp://user:pass@ip/stream" /></label>
      </div>
      <div id="panelMJPEG" class="soft-panel panel-hidden">
        <h3>MJPEG</h3>
        <label>MJPEG URL<input id="mjpegUrl" placeholder="http://ip:port/mjpeg" /></label>
      </div>
      <div id="panelRTMP" class="soft-panel panel-hidden">
        <h3>RTMP</h3>
        <label>RTMP URL<input id="rtmpUrl" placeholder="rtmp://ip/app/stream" /></label>
      </div>
      <div id="panelGB28181" class="soft-panel panel-hidden">
        <h3>GB28181</h3>
        <label>拉流地址<input id="gbPullUrl" placeholder="rtsp://zlm/live/340200... 或 http://.../live.flv" /></label>
      </div>
      <div id="panelONVIF" class="soft-panel panel-hidden">
        <h3>ONVIF（明文用户名/密码）</h3>
        <div class="grid two">
          <label>Endpoint<input id="onvifEndpoint" placeholder="http://ip/onvif/device_service" /></label>
          <label>ProfileToken<input id="onvifProfileToken" placeholder="可选" /></label>
        </div>
        <div class="grid two">
          <label>用户名<input id="onvifUsername" placeholder="admin" /></label>
          <label>密码<input id="onvifPassword" type="text" placeholder="123456" /></label>
        </div>
        <label>绑定 RTSP URL<input id="onvifRtspUrl" placeholder="rtsp://user:pass@ip/stream" /></label>
      </div>
      <div id="panelUSB" class="soft-panel panel-hidden">
        <h3>USB 摄像头</h3>
        <div class="grid two">
          <label>设备名称<input id="usbName" placeholder="HD Pro Webcam C920 或 /dev/video0" /></label>
          <label>分辨率<input id="usbResolution" value="1280x720" /></label>
        </div>
        <label>帧率（fps）<input id="usbFramerate" type="number" value="30" /></label>
      </div>
      <label>高级模式 FFmpeg 命令（必须包含 {URL}）
        <textarea id="ffmpegCommand" rows="3" placeholder="ffmpeg ... -f flv {URL}"></textarea>
      </label>
      <div class="actions">
        <button id="btnFillAdvancedCmd">按输入类型填充推荐命令</button>
      </div>
      <p class="soft-note">提示：高级模式命令是“手动托管”，切换输入源不会自动强改你已编辑的命令；可点击上方按钮快速生成模板。</p>

      <div class="soft-panel">
        <h3>本地预览（调试画面，不会推到平台）</h3>
        <p class="soft-note">建议先在这里确认摄像头/地址有效，再点击“开始推流”。关闭预览会立即释放资源。</p>
        <div class="grid two">
          <label>预览宽度（px）
            <input id="previewWidth" type="number" value="960" min="240" max="1920" />
          </label>
          <label>预览帧率（fps）
            <input id="previewFps" type="number" value="10" min="1" max="20" />
          </label>
        </div>
        <div class="grid two">
          <label>预览协议
            <select id="previewMode">
              <option value="auto" selected>自动（RTSP/ONVIF 优先 WebRTC）</option>
              <option value="webrtc">WebRTC</option>
              <option value="mjpeg">MJPEG</option>
            </select>
          </label>
          <label>说明
            <input value="WebRTC 延迟更低，通常也比 MJPEG 更省带宽。" readonly />
          </label>
        </div>
        <div class="actions">
          <button id="btnStartLocalPreview">开启本地预览</button>
          <button id="btnStopLocalPreview">关闭本地预览</button>
        </div>
        <div class="preview-panel">
          <img id="localPreviewImage" alt="推流本地预览画面" />
          <video id="localPreviewVideo" autoplay muted playsinline controls></video>
          <div id="localPreviewInfo" class="soft-note">本地预览默认关闭，点击“开启本地预览”后按当前配置拉流并显示。</div>
        </div>
      </div>

      <div class="soft-panel">
        <h3>拼屏推流（同一场直播多个摄像头）</h3>
        <div class="grid two">
          <label>启用拼屏
            <select id="multiInputEnabled">
              <option value="false" selected>关闭</option>
              <option value="true">开启</option>
            </select>
          </label>
          <label>布局模式
            <select id="multiInputLayout">
              <option value="canvas">画布自由排布（Canvas）</option>
              <option value="focus">主画面优先（Focus）</option>
              <option value="2x2">2x2</option>
              <option value="3x3">3x3</option>
              <option value="4x4">4x4</option>
              <option value="3x2">3x2</option>
            </select>
          </label>
        </div>
        <p class="soft-note">支持拖拽排序、每路标题叠加、主画面优先。至少 2 路源才能生效。</p>
        <div class="grid two">
          <label>从摄像头库添加（可多选）
            <select id="multiInputCameraPicker" multiple size="8"></select>
          </label>
          <div class="soft-panel">
            <h4>手动添加一条源</h4>
            <label>URL
              <input id="multiInputManualUrl" placeholder="rtsp:// / http:// / rtmp:// / 本地文件路径" />
            </label>
            <label>标题
              <input id="multiInputManualTitle" placeholder="例如：主机位 / 侧机位" />
            </label>
            <div class="actions">
              <button id="btnMultiInputAddManual">添加该源</button>
            </div>
          </div>
        </div>
        <div class="actions">
          <button id="btnMultiInputAddSelected">添加选中摄像头</button>
          <button id="btnMultiInputAutoLayout">自动网格排布</button>
          <button id="btnMultiInputClear">清空拼屏源</button>
        </div>
        <div class="soft-panel">
          <h4>画布编辑器（拖拽/缩放）</h4>
          <p class="soft-note">拖动画面块调整位置，拖动右下角圆点调整大小。双击画面块可设为主画面。</p>
          <div id="multiInputCanvas" class="mosaic-canvas"></div>
        </div>
        <div id="multiInputList" class="mosaic-list"></div>
      </div>
    </section>

    <section class="page-card">
      <h2>执行操作</h2>
      <h3>配置操作</h3>
      <div class="actions">
        <button id="load">读取配置</button>
        <button id="save" data-perm="operator,admin">保存配置</button>
      </div>
      <h3>推流控制</h3>
      <div class="actions">
        <button id="start" class="btn-success btn-lg" data-perm="operator,admin">开始推流</button>
        <button id="stop" class="btn-danger btn-lg" data-perm="operator,admin">停止推流</button>
        <button id="restart" class="btn-warning btn-lg" data-perm="operator,admin">重启推流</button>
        <button id="status">读取状态</button>
      </div>
      <div class="soft-note">状态每 5 秒自动刷新，你也可以手动点击“读取状态”。</div>
      <div class="actions">
        <button id="btnOpenAdvancedConsole" class="btn-ghost">打开高级控制台</button>
      </div>
      <pre id="box">{}</pre>
    </section>
  </main>

  <script src="/app/pages/shared.js"></script>
  <script>
    const { initPage, requestJSON, showJSON, bindAction, showToast, showConfirm, markFields, statusBadge, createPoller, setPanelVisible } = window.GoverShared;
    initPage({ active: "push" });

    const cameraMap = new Map();
    const videoMaterialMap = new Map();
    const audioMaterialMap = new Map();
    let pendingVideoMaterialId = "";
    let pendingAudioMaterialId = "";
    let localPreviewRunning = false;
    let localPreviewPeer = null;
    let localPreviewSessionId = "";
    let multiInputSources = [];

    function asText(id) {
      return String(document.getElementById(id).value || "").trim();
    }

    function asNumber(id, fallback) {
      const value = Number(document.getElementById(id).value || 0);
      return Number.isFinite(value) ? value : fallback;
    }

    function asBool(id) {
      return String(document.getElementById(id).value || "").toLowerCase() === "true";
    }

    const PUSH_FFMPEG_STAGE_ORDER = ["detect", "download", "extract", "verify", "save"];

    function setPushFFmpegProgress(progress, message, stage) {
      const percent = Math.max(0, Math.min(100, Number(progress || 0)));
      const bar = document.getElementById("pushFFmpegProgressValue");
      const text = document.getElementById("pushFFmpegProgressText");
      if (bar) {
        bar.style.width = `${percent}%`;
      }
      if (text) {
        text.textContent = String(message || "").trim() || "...";
      }
      const wrap = document.getElementById("pushFFmpegStageList");
      if (!wrap) return;
      const active = String(stage || "").trim();
      const activeIndex = PUSH_FFMPEG_STAGE_ORDER.indexOf(active);
      wrap.querySelectorAll("[data-stage]").forEach((node) => {
        const key = String(node.getAttribute("data-stage") || "").trim();
        const idx = PUSH_FFMPEG_STAGE_ORDER.indexOf(key);
        node.classList.remove("badge-success", "badge-info", "badge-neutral");
        if (percent >= 100) {
          node.classList.add("badge-success");
        } else if (activeIndex >= 0 && idx < activeIndex) {
          node.classList.add("badge-success");
        } else if (activeIndex >= 0 && idx === activeIndex) {
          node.classList.add("badge-info");
        } else {
          node.classList.add("badge-neutral");
        }
      });
    }

    function applyPushFFmpegProgressList(list) {
      const steps = Array.isArray(list) ? list : [];
      if (!steps.length) return;
      let progress = 0;
      let message = "";
      let stage = "";
      for (const step of steps) {
        const p = Number((step && step.progress) || 0);
        if (Number.isFinite(p)) progress = Math.max(progress, p);
        if (step && step.message) message = String(step.message || "").trim() || message;
        if (step && step.stage) stage = String(step.stage || "").trim() || stage;
      }
      setPushFFmpegProgress(progress, message || "ok", stage || "detect");
    }

    function updatePushFFmpegCdnCustomVisibility() {
      const value = asText("pushFFmpegCdnPreset");
      setPanelVisible("pushFFmpegCdnCustomWrap", value === "__custom__");
    }

    function currentPushFFmpegCDNPrefix() {
      const value = asText("pushFFmpegCdnPreset");
      if (value === "__custom__") {
        return asText("pushFFmpegCdnCustom");
      }
      return value;
    }

    function normalizeBitrateKbps(value) {
      const num = Number(value || 0);
      if (!Number.isFinite(num) || num <= 0) return 0;
      if (num > 120000) return 120000;
      return Math.round(num);
    }

    function syncBitrateCustomVisibility() {
      const preset = asText("bitratePreset");
      const wrap = document.getElementById("bitrateCustomWrap");
      wrap.style.display = preset === "custom" ? "" : "none";
    }

    function applyBitratePresetFromValue(value) {
      const normalized = normalizeBitrateKbps(value);
      const presetEl = document.getElementById("bitratePreset");
      const customEl = document.getElementById("bitrateCustom");
      if (!normalized) {
        presetEl.value = "auto";
      } else if (["2000", "3500", "5000", "8000", "12000"].includes(String(normalized))) {
        presetEl.value = String(normalized);
      } else {
        presetEl.value = "custom";
        customEl.value = String(normalized);
      }
      if (!customEl.value) {
        customEl.value = "4500";
      }
      syncBitrateCustomVisibility();
    }

    function currentBitrateKbps() {
      const preset = asText("bitratePreset");
      if (preset === "auto") return 0;
      if (preset === "custom") {
        return normalizeBitrateKbps(asNumber("bitrateCustom", 4500));
      }
      return normalizeBitrateKbps(preset);
    }

    function setPushStatusView(statusValue) {
      const status = Number(statusValue || 0);
      let text = "已停止";
      let type = "neutral";
      let detail = "推流进程当前未运行。";
      if (status === 3) {
        text = "运行中";
        type = "success";
        detail = "推流正常进行中。";
      } else if (status === 1) {
        text = "启动中";
        type = "warning";
        detail = "正在启动 FFmpeg 推流进程。";
      } else if (status === 4) {
        text = "重试中";
        type = "warning";
        detail = "推流失败后等待自动重试。";
      }
      const old = document.getElementById("pushStatusBadge");
      if (old) {
        old.outerHTML = statusBadge(text, type).replace("<span", '<span id="pushStatusBadge"');
      }
      document.getElementById("pushStatusText").textContent = detail;
    }

    function setLocalPreviewInfo(text) {
      document.getElementById("localPreviewInfo").textContent = text || "";
    }

    function stopLocalPreviewPeer() {
      if (localPreviewPeer) {
        try {
          localPreviewPeer.ontrack = null;
          localPreviewPeer.onconnectionstatechange = null;
          localPreviewPeer.close();
        } catch (_) {
          // Ignore close errors.
        }
      }
      localPreviewPeer = null;
      if (localPreviewSessionId) {
        requestJSON("/api/v1/push/preview/webrtc/close", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sessionId: localPreviewSessionId }),
        }).catch(() => {});
      }
      localPreviewSessionId = "";
    }

    function stopLocalPreview() {
      const img = document.getElementById("localPreviewImage");
      const video = document.getElementById("localPreviewVideo");
      localPreviewRunning = false;
      stopLocalPreviewPeer();
      img.style.display = "none";
      img.src = "";
      video.pause();
      video.style.display = "none";
      video.srcObject = null;
      setLocalPreviewInfo("本地预览已关闭。");
    }

    function waitForICEGatheringComplete(peer) {
      if (!peer || peer.iceGatheringState === "complete") {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        const onState = () => {
          if (peer.iceGatheringState === "complete") {
            peer.removeEventListener("icegatheringstatechange", onState);
            resolve();
          }
        };
        peer.addEventListener("icegatheringstatechange", onState);
      });
    }

    function shouldUseWebRTCPreview() {
      const mode = asText("previewMode") || "auto";
      if (mode === "webrtc") return true;
      if (mode === "mjpeg") return false;
      const inputType = asText("inputType");
      if (inputType === "rtsp" || inputType === "onvif") return true;
      if (inputType === "gb28181") {
        const gb = asText("gbPullUrl").toLowerCase();
        return gb.startsWith("rtsp://") || gb.startsWith("rtsps://");
      }
      if (asBool("multiInputEnabled")) {
        return multiInputSources.some((item) => {
          const value = String((item && item.url) || "").trim().toLowerCase();
          return value.startsWith("rtsp://") || value.startsWith("rtsps://");
        });
      }
      return false;
    }

    async function startLocalPreviewWebRTC() {
      stopLocalPreviewPeer();
      const video = document.getElementById("localPreviewVideo");
      const img = document.getElementById("localPreviewImage");
      img.style.display = "none";
      img.src = "";

      const peer = new RTCPeerConnection({ iceServers: [] });
      try {
        localPreviewPeer = peer;
        const stream = new MediaStream();
        video.srcObject = stream;
        video.style.display = "block";
        localPreviewRunning = true;
        setLocalPreviewInfo("正在建立 WebRTC 本地预览连接...");

        peer.ontrack = (event) => {
          const tracks = event.streams && event.streams[0] ? event.streams[0].getTracks() : [event.track];
          for (const track of tracks) {
            if (stream.getTracks().find((item) => item.id === track.id)) continue;
            stream.addTrack(track);
          }
        };

        peer.onconnectionstatechange = () => {
          if (!localPreviewRunning) return;
          const state = peer.connectionState;
          if (state === "connected") {
            setLocalPreviewInfo("WebRTC 本地预览已连接。");
          } else if (state === "failed" || state === "disconnected" || state === "closed") {
            setLocalPreviewInfo(`WebRTC 连接状态：${state}`);
          }
        };

        const offer = await peer.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: true });
        await peer.setLocalDescription(offer);
        await waitForICEGatheringComplete(peer);

        const local = peer.localDescription;
        if (!local || !local.sdp) {
          throw new Error("WebRTC 本地 offer 为空");
        }
        const result = await requestJSON("/api/v1/push/preview/webrtc/offer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ type: local.type || "offer", sdp: local.sdp }),
        });
        const answer = result && result.data ? result.data : {};
        if (!answer.sdp) {
          throw new Error("WebRTC answer 为空");
        }
        await peer.setRemoteDescription({
          type: answer.type || "answer",
          sdp: answer.sdp,
        });
        localPreviewSessionId = String(answer.sessionId || "").trim();
        try {
          await video.play();
        } catch (_) {
          // Browser autoplay policy may block; keep controls visible for manual play.
        }
        setLocalPreviewInfo("WebRTC 本地预览已启动。");
      } catch (error) {
        stopLocalPreview();
        throw error;
      }
    }

    function switchInputPanels() {

      const inputType = asText("inputType");
      setPanelVisible("panelVIDEO", inputType === "video");
      setPanelVisible("panelRTSP", inputType === "rtsp");
      setPanelVisible("panelMJPEG", inputType === "mjpeg");
      setPanelVisible("panelRTMP", inputType === "rtmp");
      setPanelVisible("panelGB28181", inputType === "gb28181");
      setPanelVisible("panelONVIF", inputType === "onvif");
      setPanelVisible("panelUSB", inputType === "usb_camera" || inputType === "usb_camera_plus");
    }

    function toMaterialRows(result) {
      const data = result && result.data ? result.data : {};
      if (Array.isArray(data.data)) return data.data;
      if (Array.isArray(data)) return data;
      return [];
    }

    function fillMaterialSelect(selectId, materialMap, rows, emptyText) {
      const select = document.getElementById(selectId);
      select.innerHTML = "";
      materialMap.clear();
      const base = document.createElement("option");
      base.value = "";
      base.textContent = emptyText;
      select.appendChild(base);
      for (const item of rows) {
        const id = Number(item && item.id ? item.id : 0);
        if (!id) continue;
        const key = String(id);
        materialMap.set(key, item);
        const option = document.createElement("option");
        option.value = key;
        const fileType = String(item.fileType || "").trim();
        const typeText = fileType ? `[${fileType}] ` : "";
        option.textContent = `${typeText}${item.name || `Material-${id}`}`;
        select.appendChild(option);
      }
    }

    function setPendingMaterialSelection(videoID, audioID) {
      pendingVideoMaterialId = videoID > 0 ? String(videoID) : "";
      pendingAudioMaterialId = audioID > 0 ? String(audioID) : "";
      applyPendingMaterialSelection();
    }

    function applyPendingMaterialSelection() {
      const videoSelect = document.getElementById("videoMaterialSelect");
      const audioSelect = document.getElementById("audioMaterialSelect");
      if (!pendingVideoMaterialId) {
        videoSelect.value = "";
      } else if (videoMaterialMap.has(pendingVideoMaterialId)) {
        videoSelect.value = pendingVideoMaterialId;
      }
      if (!pendingAudioMaterialId) {
        audioSelect.value = "";
      } else if (audioMaterialMap.has(pendingAudioMaterialId)) {
        audioSelect.value = pendingAudioMaterialId;
      }
      updateMaterialHint();
    }

    function updateMaterialHint() {
      const videoID = asText("videoMaterialSelect");
      const audioID = asText("audioMaterialSelect");
      const video = videoMaterialMap.get(videoID);
      const audio = audioMaterialMap.get(audioID);
      const parts = [];
      if (video) {
        parts.push(`视频：${video.name || `#${videoID}`} ${video.path || video.fullPath || ""}`.trim());
      }
      if (audio) {
        parts.push(`音频：${audio.name || `#${audioID}`} ${audio.path || audio.fullPath || ""}`.trim());
      }
      const hint = parts.length ? parts.join(" | ") : "请选择一个视频素材作为推流输入源。";
      document.getElementById("videoMaterialHint").textContent = hint;
    }

    async function loadMaterialSources() {
      const [videoResult, audioResult] = await Promise.all([
        requestJSON("/api/v1/materials?page=1&limit=200&fileType=1"),
        requestJSON("/api/v1/materials?page=1&limit=200&fileType=2"),
      ]);
      const videoRows = toMaterialRows(videoResult);
      const audioRows = toMaterialRows(audioResult);
      fillMaterialSelect("videoMaterialSelect", videoMaterialMap, videoRows, "（请选择视频素材）");
      fillMaterialSelect("audioMaterialSelect", audioMaterialMap, audioRows, "（不使用）");
      applyPendingMaterialSelection();
      const info = {
        code: 0,
        message: `素材加载完成：视频 ${videoRows.length} 条，音频 ${audioRows.length} 条`,
        data: {
          videoCount: videoRows.length,
          audioCount: audioRows.length,
        },
      };
      showJSON("box", info);
      return info;
    }

    function isUsbTemplateCommand(commandText) {
      const lower = String(commandText || "").toLowerCase();
      return lower.includes("-f dshow") || lower.includes("video=\"") || lower.includes("-f v4l2") || lower.includes("/dev/video");
    }

    function recommendedAdvancedCommand(inputType) {
      const type = String(inputType || "").toLowerCase();
      const commonOut = "-vcodec libx264 -pix_fmt yuv420p -r 25 -g 50 -b:v 3500k -maxrate 3500k -bufsize 7000k -preset veryfast -tune zerolatency -f flv {URL}";
      if (type === "rtsp" || type === "onvif") {
        return `ffmpeg -rtsp_transport tcp -i \"${type === "onvif" ? "rtsp://user:pass@ip/stream" : "rtsp://user:pass@ip/stream"}\" -an ${commonOut}`;
      }
      if (type === "mjpeg") {
        return "ffmpeg -f mjpeg -i \"http://ip:port/mjpeg\" -an " + commonOut;
      }
      if (type === "rtmp") {
        return "ffmpeg -i \"rtmp://ip/app/stream\" -an " + commonOut;
      }
      if (type === "gb28181") {
        return "ffmpeg -i \"rtsp://media-server/live/340200...\" -an " + commonOut;
      }
      if (type === "usb_camera" || type === "usb_camera_plus") {
        return "ffmpeg -f dshow -video_size 1280x720 -framerate 30 -i video=\"HD Pro Webcam C920\" -an " + commonOut;
      }
      return "ffmpeg -re -i \"input.mp4\" -an " + commonOut;
    }

    function autoSuggestAdvancedCommand() {
      const model = asNumber("model", 1);
      if (model !== 2) return;
      const inputType = asText("inputType");
      const commandEl = document.getElementById("ffmpegCommand");
      const current = commandEl.value || "";
      if (!current.trim()) {
        commandEl.value = recommendedAdvancedCommand(inputType);
        return;
      }
      const networkType = inputType === "rtsp" || inputType === "mjpeg" || inputType === "onvif" || inputType === "rtmp" || inputType === "gb28181";
      if (networkType && isUsbTemplateCommand(current)) {
        commandEl.value = recommendedAdvancedCommand(inputType);
      }
    }

    function cameraTypeLabel(type) {
      const value = String(type || "").toLowerCase();
      if (value === "rtsp") return "RTSP";
      if (value === "mjpeg") return "MJPEG";
      if (value === "rtmp") return "RTMP";
      if (value === "gb28181") return "GB28181";
      if (value === "onvif") return "ONVIF";
      if (value === "usb") return "USB";
      return value || "unknown";
    }

    function cameraHint(item) {
      if (!item) return "";
      const type = String(item.sourceType || "").toLowerCase();
      if (type === "rtsp" || type === "onvif") return item.rtspUrl || item.onvifEndpoint || "";
      if (type === "mjpeg") return item.mjpegUrl || "";
      if (type === "rtmp") return item.rtmpUrl || "";
      if (type === "gb28181") return item.gbPullUrl || item.gbDeviceId || "";
      if (type === "usb") return item.usbDeviceName || "";
      return "";
    }

    function cameraToMosaicSource(item) {
      if (!item) return null;
      const type = String(item.sourceType || "").toLowerCase();
      let url = "";
      if (type === "rtsp" || type === "onvif") {
        url = String(item.rtspUrl || "").trim();
      } else if (type === "mjpeg") {
        url = String(item.mjpegUrl || "").trim();
      } else if (type === "rtmp") {
        url = String(item.rtmpUrl || "").trim();
      } else if (type === "gb28181") {
        url = String(item.gbPullUrl || "").trim();
      }
      if (!url) {
        return null;
      }
      return {
        url,
        title: String(item.name || cameraTypeLabel(type) || "Source").trim(),
        primary: false,
        enableAudio: false,
        sourceType: type,
        materialId: 0,
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        z: 0,
      };
    }

    function normalizeMultiInputSource(item) {
      if (!item || typeof item !== "object") return null;
      const url = String(item.url || "").trim();
      if (!url) return null;
      return {
        url,
        title: String(item.title || "").trim(),
        primary: Boolean(item.primary),
        enableAudio: Boolean(item.enableAudio),
        sourceType: String(item.sourceType || "").trim(),
        materialId: Number(item.materialId || 0) || 0,
        x: Number(item.x || 0) || 0,
        y: Number(item.y || 0) || 0,
        w: Number(item.w || 0) || 0,
        h: Number(item.h || 0) || 0,
        z: Number(item.z || 0) || 0,
      };
    }

    function ensurePrimaryMultiInputSource(items) {
      if (!Array.isArray(items) || items.length === 0) return;
      let primaryIndex = items.findIndex((item) => Boolean(item && item.primary));
      if (primaryIndex < 0) primaryIndex = 0;
      for (let i = 0; i < items.length; i++) {
        items[i].primary = i === primaryIndex;
      }
    }

    function ensureSingleAudioSource(items) {
      if (!Array.isArray(items) || items.length === 0) return;
      let audioIndex = items.findIndex((item) => Boolean(item && item.enableAudio));
      if (audioIndex < 0) return;
      for (let i = 0; i < items.length; i++) {
        items[i].enableAudio = i === audioIndex;
      }
    }

    function clamp01(value) {
      const num = Number(value || 0);
      if (!Number.isFinite(num)) return 0;
      if (num < 0) return 0;
      if (num > 1) return 1;
      return num;
    }

    function autoLayoutMultiInput(items) {
      const list = Array.isArray(items) ? items : [];
      if (!list.length) return;
      const cols = Math.max(1, Math.ceil(Math.sqrt(list.length)));
      const rows = Math.max(1, Math.ceil(list.length / cols));
      const cellW = 1 / cols;
      const cellH = 1 / rows;
      const marginX = Math.min(0.01, cellW * 0.08);
      const marginY = Math.min(0.01, cellH * 0.08);
      for (let index = 0; index < list.length; index++) {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const item = list[index];
        item.x = clamp01(col * cellW + marginX);
        item.y = clamp01(row * cellH + marginY);
        item.w = clamp01(Math.max(0.08, cellW - marginX * 2));
        item.h = clamp01(Math.max(0.08, cellH - marginY * 2));
        item.z = index;
      }
    }

    function ensureCanvasLayout(items) {
      if (!Array.isArray(items) || !items.length) return;
      const hasAnyRect = items.some((item) => Number(item && item.w) > 0 || Number(item && item.h) > 0);
      if (!hasAnyRect) {
        autoLayoutMultiInput(items);
        return;
      }
      for (let index = 0; index < items.length; index++) {
        const item = items[index];
        const w = Number(item.w || 0);
        const h = Number(item.h || 0);
        item.w = w > 0 ? clamp01(Math.max(0.08, w)) : 0.24;
        item.h = h > 0 ? clamp01(Math.max(0.08, h)) : 0.24;
        item.x = clamp01(item.x || 0);
        item.y = clamp01(item.y || 0);
        if (item.x + item.w > 1) item.x = Math.max(0, 1 - item.w);
        if (item.y + item.h > 1) item.y = Math.max(0, 1 - item.h);
        item.z = Number.isFinite(Number(item.z)) ? Number(item.z) : index;
      }
      items.sort((a, b) => Number(a.z || 0) - Number(b.z || 0));
      for (let i = 0; i < items.length; i++) {
        items[i].z = i;
      }
    }

    function parseResolutionRatio() {
      const raw = asText("resolution") || "1280x720";
      const parts = raw.toLowerCase().split("x");
      if (parts.length !== 2) return { width: 16, height: 9 };
      const width = Number(parts[0] || 0);
      const height = Number(parts[1] || 0);
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        return { width: 16, height: 9 };
      }
      return { width, height };
    }

    function renderMultiInputCanvas() {
      const canvas = document.getElementById("multiInputCanvas");
      if (!canvas) return;
      const ratio = parseResolutionRatio();
      canvas.style.aspectRatio = `${ratio.width} / ${ratio.height}`;
      canvas.innerHTML = "";
      if (!multiInputSources.length) return;
      ensureCanvasLayout(multiInputSources);

      const startDrag = (index, mode, downEvent) => {
        const rect = canvas.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        const target = multiInputSources[index];
        if (!target) return;
        const start = {
          x: target.x,
          y: target.y,
          w: target.w,
          h: target.h,
          clientX: downEvent.clientX,
          clientY: downEvent.clientY,
        };
        const move = (moveEvent) => {
          const dx = (moveEvent.clientX - start.clientX) / rect.width;
          const dy = (moveEvent.clientY - start.clientY) / rect.height;
          if (mode === "move") {
            target.x = clamp01(start.x + dx);
            target.y = clamp01(start.y + dy);
            if (target.x + target.w > 1) target.x = 1 - target.w;
            if (target.y + target.h > 1) target.y = 1 - target.h;
          } else {
            target.w = clamp01(Math.max(0.08, start.w + dx));
            target.h = clamp01(Math.max(0.08, start.h + dy));
            if (target.x + target.w > 1) target.w = 1 - target.x;
            if (target.y + target.h > 1) target.h = 1 - target.y;
          }
          renderMultiInputCanvas();
        };
        const up = () => {
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", up);
          renderMultiInputList();
        };
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);
      };

      multiInputSources.forEach((item, index) => {
        const node = document.createElement("div");
        node.className = `mosaic-canvas-item${item.primary ? " primary" : ""}`;
        node.style.left = `${(item.x * 100).toFixed(4)}%`;
        node.style.top = `${(item.y * 100).toFixed(4)}%`;
        node.style.width = `${(item.w * 100).toFixed(4)}%`;
        node.style.height = `${(item.h * 100).toFixed(4)}%`;
        node.style.zIndex = String(index + 10);

        const head = document.createElement("div");
        head.className = "mosaic-canvas-head";
        head.innerHTML = `<span class="mosaic-canvas-label">${item.title || `Source-${index + 1}`}</span><span>#${index + 1}</span>`;
        head.onmousedown = (event) => {
          event.preventDefault();
          document.getElementById("multiInputLayout").value = "canvas";
          startDrag(index, "move", event);
        };
        head.ondblclick = (event) => {
          event.preventDefault();
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].primary = i === index;
          }
          renderMultiInputList();
          renderMultiInputCanvas();
        };

        const body = document.createElement("div");
        body.className = "mosaic-canvas-body";
        body.textContent = item.url || "";

        const handle = document.createElement("div");
        handle.className = "mosaic-canvas-handle";
        handle.onmousedown = (event) => {
          event.preventDefault();
          document.getElementById("multiInputLayout").value = "canvas";
          startDrag(index, "resize", event);
        };

        node.appendChild(head);
        node.appendChild(body);
        node.appendChild(handle);
        canvas.appendChild(node);
      });
    }

    function mergeAndSetMultiInputSources(items) {
      const next = [];
      const seen = new Set();
      for (const raw of items || []) {
        const normalized = normalizeMultiInputSource(raw);
        if (!normalized) continue;
        if (seen.has(normalized.url)) continue;
        seen.add(normalized.url);
        next.push(normalized);
      }
      ensurePrimaryMultiInputSource(next);
      ensureSingleAudioSource(next);
      ensureCanvasLayout(next);
      multiInputSources = next;
      document.getElementById("sourceAudioEnabled").value = next.some((item) => item.enableAudio) ? "true" : "false";
      renderMultiInputList();
      renderMultiInputCanvas();
    }

    function renderMultiInputList() {
      const container = document.getElementById("multiInputList");
      if (!container) return;
      container.innerHTML = "";
      if (!multiInputSources.length) {
        container.innerHTML = '<div class="mosaic-item-empty">当前没有拼屏源。可从“摄像头库多选”添加，或手动添加 URL。</div>';
        return;
      }
      multiInputSources.forEach((item, index) => {
        const row = document.createElement("div");
        row.className = "mosaic-item";
        row.draggable = true;
        row.dataset.index = String(index);

        row.addEventListener("dragstart", (event) => {
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", String(index));
        });
        row.addEventListener("dragover", (event) => {
          event.preventDefault();
          row.classList.add("drag-over");
          event.dataTransfer.dropEffect = "move";
        });
        row.addEventListener("dragleave", () => {
          row.classList.remove("drag-over");
        });
        row.addEventListener("drop", (event) => {
          event.preventDefault();
          row.classList.remove("drag-over");
          const from = Number(event.dataTransfer.getData("text/plain"));
          const to = index;
          if (!Number.isFinite(from) || from < 0 || from >= multiInputSources.length || from === to) return;
          const moved = multiInputSources.splice(from, 1)[0];
          multiInputSources.splice(to, 0, moved);
          ensurePrimaryMultiInputSource(multiInputSources);
          ensureSingleAudioSource(multiInputSources);
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].z = i;
          }
          renderMultiInputList();
          renderMultiInputCanvas();
        });

        const head = document.createElement("div");
        head.className = "mosaic-item-head";

        const handle = document.createElement("span");
        handle.className = "mosaic-item-handle";
        handle.textContent = "↕";
        head.appendChild(handle);

        const titleInput = document.createElement("input");
        titleInput.className = "mosaic-item-title";
        titleInput.value = item.title || "";
        titleInput.placeholder = `来源 ${index + 1} 标题`;
        titleInput.onchange = () => {
          multiInputSources[index].title = String(titleInput.value || "").trim();
          renderMultiInputCanvas();
        };
        head.appendChild(titleInput);

        const primaryBtn = document.createElement("button");
        primaryBtn.type = "button";
        primaryBtn.className = item.primary ? "btn-success btn-mini" : "btn-ghost btn-mini";
        primaryBtn.textContent = item.primary ? "主画面" : "设为主画面";
        primaryBtn.onclick = () => {
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].primary = i === index;
          }
          renderMultiInputList();
          renderMultiInputCanvas();
        };
        head.appendChild(primaryBtn);

        const audioBtn = document.createElement("button");
        audioBtn.type = "button";
        audioBtn.className = item.enableAudio ? "btn-warning btn-mini" : "btn-ghost btn-mini";
        audioBtn.textContent = item.enableAudio ? "声音:开" : "声音:关";
        audioBtn.onclick = () => {
          const nextState = !multiInputSources[index].enableAudio;
          for (let i = 0; i < multiInputSources.length; i++) {
            multiInputSources[i].enableAudio = false;
          }
          multiInputSources[index].enableAudio = nextState;
          document.getElementById("sourceAudioEnabled").value = nextState ? "true" : "false";
          renderMultiInputList();
        };
        head.appendChild(audioBtn);

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "btn-danger btn-mini";
        removeBtn.textContent = "移除";
        removeBtn.onclick = () => {
          multiInputSources.splice(index, 1);
          ensurePrimaryMultiInputSource(multiInputSources);
          ensureSingleAudioSource(multiInputSources);
          document.getElementById("sourceAudioEnabled").value = multiInputSources.some((item) => item.enableAudio) ? "true" : "false";
          ensureCanvasLayout(multiInputSources);
          renderMultiInputList();
          renderMultiInputCanvas();
        };
        head.appendChild(removeBtn);

        const urlInput = document.createElement("input");
        urlInput.value = item.url || "";
        urlInput.placeholder = "URL";
        urlInput.onchange = () => {
          multiInputSources[index].url = String(urlInput.value || "").trim();
          renderMultiInputCanvas();
        };

        const info = document.createElement("div");
        info.className = "mosaic-item-url";
        info.textContent = `类型：${item.sourceType || "custom"} ｜ 拖拽可调整布局顺序`;

        row.appendChild(head);
        row.appendChild(urlInput);
        row.appendChild(info);
        container.appendChild(row);
      });
    }

    function collectMultiInputSourcesForPayload() {
      ensureCanvasLayout(multiInputSources);
      const normalized = [];
      const seen = new Set();
      for (const item of multiInputSources) {
        const source = normalizeMultiInputSource(item);
        if (!source) continue;
        if (seen.has(source.url)) continue;
        seen.add(source.url);
        source.x = clamp01(source.x);
        source.y = clamp01(source.y);
        source.w = clamp01(Math.max(0.08, source.w || 0));
        source.h = clamp01(Math.max(0.08, source.h || 0));
        source.z = normalized.length;
        normalized.push(source);
      }
      ensurePrimaryMultiInputSource(normalized);
      ensureSingleAudioSource(normalized);
      multiInputSources = normalized;
      return normalized;
    }

    function fillMultiInputCameraPicker(items) {
      const picker = document.getElementById("multiInputCameraPicker");
      if (!picker) return;
      picker.innerHTML = "";
      for (const item of items || []) {
        const source = cameraToMosaicSource(item);
        if (!source) continue;
        const option = document.createElement("option");
        option.value = String(item.id);
        option.textContent = `${item.name || `Camera-${item.id}`} [${cameraTypeLabel(item.sourceType)}]`;
        picker.appendChild(option);
      }
    }

    function addSelectedCamerasToMultiInput() {
      const picker = document.getElementById("multiInputCameraPicker");
      if (!picker) return { added: 0, skipped: 0 };
      const selected = Array.from(picker.selectedOptions || []);
      if (!selected.length) throw new Error("请先在摄像头库里选择至少一项");

      let added = 0;
      let skipped = 0;
      const existing = new Set(multiInputSources.map((item) => item.url));
      for (const option of selected) {
        const id = Number(option.value || 0);
        const camera = cameraMap.get(id);
        const source = cameraToMosaicSource(camera);
        if (!source || existing.has(source.url)) {
          skipped++;
          continue;
        }
        existing.add(source.url);
        multiInputSources.push(source);
        added++;
      }
      ensurePrimaryMultiInputSource(multiInputSources);
      ensureSingleAudioSource(multiInputSources);
      ensureCanvasLayout(multiInputSources);
      renderMultiInputList();
      renderMultiInputCanvas();
      return { added, skipped };
    }

    function addManualMultiInputSource() {
      const url = String(document.getElementById("multiInputManualUrl").value || "").trim();
      const title = String(document.getElementById("multiInputManualTitle").value || "").trim();
      if (!url) throw new Error("请先输入拼屏源 URL");
      if (multiInputSources.some((item) => item.url === url)) {
        throw new Error("该 URL 已经在拼屏列表中");
      }
      const sourceType = url.startsWith("rtsp://") ? "rtsp"
        : (url.includes(".mjpg") || url.includes("mjpeg")) ? "mjpeg"
        : url.startsWith("rtmp://") ? "rtmp"
        : "custom";
      multiInputSources.push({
        url,
        title: title || `Source-${multiInputSources.length + 1}`,
        primary: false,
        enableAudio: false,
        sourceType,
        materialId: 0,
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        z: multiInputSources.length,
      });
      ensurePrimaryMultiInputSource(multiInputSources);
      ensureSingleAudioSource(multiInputSources);
      ensureCanvasLayout(multiInputSources);
      renderMultiInputList();
      renderMultiInputCanvas();
      document.getElementById("multiInputManualUrl").value = "";
      document.getElementById("multiInputManualTitle").value = "";
    }

    function fillByCamera(item) {
      if (!item) return;
      const type = String(item.sourceType || "").toLowerCase();
      if (type === "rtsp") {
        document.getElementById("inputType").value = "rtsp";
        document.getElementById("rtspUrl").value = item.rtspUrl || "";
      } else if (type === "mjpeg") {
        document.getElementById("inputType").value = "mjpeg";
        document.getElementById("mjpegUrl").value = item.mjpegUrl || "";
      } else if (type === "rtmp") {
        document.getElementById("inputType").value = "rtmp";
        document.getElementById("rtmpUrl").value = item.rtmpUrl || "";
      } else if (type === "gb28181") {
        document.getElementById("inputType").value = "gb28181";
        document.getElementById("gbPullUrl").value = item.gbPullUrl || "";
      } else if (type === "onvif") {
        document.getElementById("inputType").value = "onvif";
        document.getElementById("onvifEndpoint").value = item.onvifEndpoint || "";
        document.getElementById("onvifUsername").value = item.onvifUsername || "";
        document.getElementById("onvifPassword").value = item.onvifPassword || "";
        document.getElementById("onvifProfileToken").value = item.onvifProfileToken || "";
        document.getElementById("onvifRtspUrl").value = item.rtspUrl || "";
      } else if (type === "usb") {
        document.getElementById("inputType").value = "usb_camera";
        document.getElementById("usbName").value = item.usbDeviceName || "";
        document.getElementById("usbResolution").value = item.usbDeviceResolution || "1280x720";
        document.getElementById("usbFramerate").value = String(item.usbDeviceFramerate || 30);
      }
      switchInputPanels();
    }

    async function loadCameras() {
      const params = new URLSearchParams();
      params.set("page", "1");
      params.set("limit", "200");
      const filterType = asText("cameraFilterType");
      if (filterType) params.set("sourceType", filterType);
      const result = await requestJSON(`/api/v1/cameras?${params.toString()}`);
      showJSON("box", result);
      const select = document.getElementById("cameraSelect");
      select.innerHTML = '<option value="">（请选择已保存摄像头）</option>';
      cameraMap.clear();
      const items = ((result || {}).data || {}).data || [];
      for (const item of items) {
        cameraMap.set(item.id, item);
        const option = document.createElement("option");
        option.value = String(item.id);
        option.textContent = `${item.name || `Camera-${item.id}`} [${cameraTypeLabel(item.sourceType)}] ${cameraHint(item)}`;
        select.appendChild(option);
      }
      fillMultiInputCameraPicker(items);
    }

    function guessFFprobePathByFFmpegPathForPush(ffmpegPath) {
      const value = String(ffmpegPath || "").trim();
      if (!value) return "";
      if (/ffmpeg\.exe$/i.test(value)) {
        return value.replace(/ffmpeg\.exe$/i, "ffprobe.exe");
      }
      if (/[\\/]ffmpeg$/i.test(value)) {
        return value.replace(/ffmpeg$/i, "ffprobe");
      }
      const trimmed = value.replace(/[\\/]+$/, "");
      if (!trimmed) return "";
      const isWindowsPath = /^[A-Za-z]:\\/.test(trimmed) || trimmed.includes("\\");
      const sep = isWindowsPath ? "\\" : "/";
      const binary = isWindowsPath ? "ffprobe.exe" : "ffprobe";
      return `${trimmed}${sep}${binary}`;
    }

    async function saveFFmpegPathByInputForPush(path) {
      const ffmpegPath = String(path || "").trim();
      if (!ffmpegPath) {
        throw new Error("请先输入 FFmpeg 二进制路径或目录");
      }
      const payload = { ffmpegPath };
      const guessedFFprobe = guessFFprobePathByFFmpegPathForPush(ffmpegPath);
      if (guessedFFprobe) payload.ffprobePath = guessedFFprobe;
      const result = await requestJSON("/api/v1/config/ffmpeg/manual-save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const cfg = ((result || {}).data || {}).config || {};
      document.getElementById("pushFFmpegPathInput").value = String(cfg.ffmpegPath || ffmpegPath);
      return result;
    }

    async function loadFFmpegPathInputForPush() {
      const result = await requestJSON("/api/v1/config");
      const cfg = ((result || {}).data || {}).config || {};
      const value = String(cfg.ffmpegPath || "").trim();
      if (value) {
        document.getElementById("pushFFmpegPathInput").value = value;
        setPushFFmpegProgress(100, `当前配置已保存：${value}`, "save");
      } else {
        setPushFFmpegProgress(0, "尚未配置 FFmpeg 路径", "detect");
      }
      return result;
    }

    async function autoDetectFFmpegPathForPush() {
      setPushFFmpegProgress(20, "正在扫描 FFmpeg 路径...", "detect");
      try {
        const result = await requestJSON("/api/v1/config/ffmpeg/auto-detect", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: "{}"
        });
        showJSON("box", result);
        const data = (result && result.data) || {};
        const ffmpegPath = String(data.ffmpegPath || "").trim();
        if (ffmpegPath) {
          document.getElementById("pushFFmpegPathInput").value = ffmpegPath;
          showToast("FFmpeg 路径扫描成功：" + ffmpegPath, "success");
          setPushFFmpegProgress(100, "已自动回填路径：" + ffmpegPath, "save");
        } else {
          showToast("未扫描到 FFmpeg，请手动输入路径后保存", "info");
        }
        return result;
      } catch (error) {
        const message = error.message || String(error);
        setPushFFmpegProgress(0, "扫描失败：" + message, "detect");
        throw new Error("自动扫描失败：" + message + "。请手动输入 FFmpeg 二进制路径后点击“保存 FFmpeg 路径”。");
      }
    }

    async function saveFFmpegPathManuallyForPush() {
      const manualPath = asText("pushFFmpegPathInput");
      setPushFFmpegProgress(35, "正在保存手动输入路径...", "verify");
      const saved = await saveFFmpegPathByInputForPush(manualPath);
      showJSON("box", saved);
      const data = (saved && saved.data) || {};
      const resolvedPath = String(data.ffmpegPath || ((data.config || {}).ffmpegPath) || manualPath).trim();
      if (resolvedPath) {
        document.getElementById("pushFFmpegPathInput").value = resolvedPath;
      }
      showToast("FFmpeg 路径已保存：" + (resolvedPath || manualPath), "success");
      setPushFFmpegProgress(100, "FFmpeg 路径已保存：" + (resolvedPath || manualPath), "save");
      return saved;
    }

    const PUSH_INSTALL_TASK_STORAGE_KEY = "gover_ffmpeg_install_task";
    const PUSH_INSTALL_TASK_STATE_STORAGE_KEY = "gover_ffmpeg_install_task_state";
    let pushInstallRunning = false;
    let pushInstallTaskId = "";
    let pushInstallWatchPromise = null;

    function setPushInstallButtonState() {
      const btn = document.getElementById("btnInstallFFmpegPush");
      if (!btn) return;
      if (pushInstallRunning) {
        btn.textContent = "取消下载并安装 FFmpeg";
      } else {
        btn.textContent = "自动下载并安装 FFmpeg";
      }
    }

    function setPushInstallTaskLabel(taskId) {
      const el = document.getElementById("pushFFmpegTaskId");
      if (!el) return;
      const value = String(taskId || "").trim();
      el.textContent = value ? `当前安装任务 ID：${value}` : "当前安装任务 ID：-";
    }

    function setPushInstallRouteLabel(route) {
      const el = document.getElementById("pushFFmpegRouteLabel");
      if (!el) return;
      const value = normalizePushInstallRouteLabel(route);
      el.textContent = value ? `本次下载线路：${value}` : "本次下载线路：-";
    }

    function normalizePushInstallRouteLabel(route) {
      const value = String(route || "").trim();
      if (!value) return "";
      if (value === "__auto__" || value.toLowerCase() === "auto") {
        return "自动（测速中）";
      }
      if (value === "direct-github" || value.toLowerCase() === "github") {
        return "直连 GitHub";
      }
      if (value === "https://gh-proxy.org/") {
        return "gh-proxy.org";
      }
      if (value === "https://hk.gh-proxy.org/") {
        return "hk.gh-proxy.org";
      }
      if (value === "https://gitproxy.click/") {
        return "gitproxy.click";
      }
      return value;
    }

    function resolvePushInstallRouteByURL(urlValue) {
      const value = String(urlValue || "").trim();
      if (!value) return "";
      if (value.startsWith("https://gh-proxy.org/")) return "gh-proxy.org";
      if (value.startsWith("https://hk.gh-proxy.org/")) return "hk.gh-proxy.org";
      if (value.startsWith("https://gitproxy.click/")) return "gitproxy.click";
      if (value.includes("github.com/SoraKasvgano/BilibiliLiveToolsGolang/releases/download/ffmpeg/")) {
        return "直连 GitHub";
      }
      return value;
    }

    function extractPushInstallRoute(task) {
      const current = task || {};
      const routeByURL = resolvePushInstallRouteByURL(
        (current.install && (current.install.downloadUrl || current.install.sourceUrl))
        || current.downloadUrl
        || ""
      );
      if (routeByURL) return routeByURL;
      const progress = Array.isArray(current.progress) ? current.progress : [];
      for (let i = progress.length - 1; i >= 0; i -= 1) {
        const msg = String((progress[i] && progress[i].message) || "").trim();
        if (!msg) continue;
        const match = msg.match(/Selected download route:\s*(.+)$/i) || msg.match(/\u5df2\u9009\u62e9\u4e0b\u8f7d\u7ebf\u8def[:\uFF1A]\s*(.+)$/);
        if (match && match[1]) {
          return String(match[1] || "").trim();
        }
      }
      return normalizePushInstallRouteLabel(current.cdnPrefix || current.CDNPrefix || "");
    }
    function rememberPushInstallTask(taskId) {
      const value = String(taskId || "").trim();
      if (!value) return;
      localStorage.setItem(PUSH_INSTALL_TASK_STORAGE_KEY, value);
      setPushInstallTaskLabel(value);
    }

    function clearRememberedPushInstallTask() {
      localStorage.removeItem(PUSH_INSTALL_TASK_STORAGE_KEY);
      setPushInstallTaskLabel("");
    }

    function getRememberedPushInstallTask() {
      return String(localStorage.getItem(PUSH_INSTALL_TASK_STORAGE_KEY) || "").trim();
    }

    function rememberPushInstallTaskState(snapshot) {
      try {
        localStorage.setItem(PUSH_INSTALL_TASK_STATE_STORAGE_KEY, JSON.stringify(snapshot || {}));
      } catch {
      }
    }

    function clearRememberedPushInstallTaskState() {
      localStorage.removeItem(PUSH_INSTALL_TASK_STATE_STORAGE_KEY);
    }

    function getRememberedPushInstallTaskState() {
      const raw = String(localStorage.getItem(PUSH_INSTALL_TASK_STATE_STORAGE_KEY) || "").trim();
      if (!raw) return null;
      try {
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : null;
      } catch {
        return null;
      }
    }

    function persistPushInstallTaskState(task) {
      const current = task || {};
      const taskId = String(current.taskId || pushInstallTaskId || getRememberedPushInstallTask()).trim();
      if (!taskId) return;
      rememberPushInstallTaskState({
        taskId,
        status: String(current.status || "").trim(),
        stage: String(current.stage || "").trim(),
        percent: Number(current.percent || 0),
        message: String(current.message || "").trim(),
        ffmpegPath: String(current.ffmpegPath || "").trim(),
        route: normalizePushInstallRouteLabel(current.selectedRoute || current.route || extractPushInstallRoute(current)),
        progress: Array.isArray(current.progress) ? current.progress : []
      });
    }

    function restorePushInstallTaskState() {
      const snapshot = getRememberedPushInstallTaskState();
      if (!snapshot) return "";
      const taskId = String(snapshot.taskId || "").trim();
      if (!taskId) return "";
      applyPushInstallTaskState({
        taskId,
        status: snapshot.status || "running",
        stage: snapshot.stage || "detect",
        percent: Number(snapshot.percent || 0),
        message: snapshot.message || "正在恢复任务进度...",
        ffmpegPath: snapshot.ffmpegPath || "",
        selectedRoute: snapshot.route || "",
        progress: Array.isArray(snapshot.progress) ? snapshot.progress : []
      });
      return taskId;
    }

    function isPushInstallTaskDone(task) {
      const status = String((task && task.status) || "").trim().toLowerCase();
      return status === "succeeded" || status === "failed" || status === "cancelled";
    }

    function applyPushInstallTaskState(task) {
      const current = task || {};
      if (Array.isArray(current.progress) && current.progress.length) {
        applyPushFFmpegProgressList(current.progress);
      }
      const stage = String(current.stage || "").trim() || "detect";
      const percent = Number(current.percent || 0);
      const message = String(current.message || "").trim() || "处理中...";
      setPushFFmpegProgress(Number.isFinite(percent) ? percent : 0, message, stage);
      const ffmpegPath = String(current.ffmpegPath || "").trim();
      if (ffmpegPath) {
        document.getElementById("pushFFmpegPathInput").value = ffmpegPath;
      }
      const taskId = String(current.taskId || pushInstallTaskId || getRememberedPushInstallTask()).trim();
      if (taskId) {
        pushInstallTaskId = taskId;
        setPushInstallTaskLabel(taskId);
      }
      const route = normalizePushInstallRouteLabel(current.selectedRoute || current.route || extractPushInstallRoute(current));
      setPushInstallRouteLabel(route);
      persistPushInstallTaskState(current);
    }

    async function queryPushInstallTask(taskId) {
      const result = await requestJSON("/api/v1/config/ffmpeg/install/status?taskId=" + encodeURIComponent(taskId));
      return (result && result.data) || {};
    }

    async function monitorPushInstallTaskBySSE(taskId) {
      const token = (window.GoverShared && typeof window.GoverShared.getAuthToken === "function")
        ? window.GoverShared.getAuthToken()
        : "";
      const headers = { Accept: "text/event-stream" };
      if (token) {
        headers.Authorization = "Bearer " + token;
      }
      const response = await fetch("/api/v1/config/ffmpeg/install/stream?taskId=" + encodeURIComponent(taskId), {
        method: "GET",
        headers,
        credentials: "same-origin"
      });
      if (!response.ok) {
        throw new Error("SSE HTTP " + response.status);
      }
      if (!response.body || !response.body.getReader) {
        throw new Error("浏览器不支持 SSE 流读取");
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";
      let lastData = null;

      while (true) {
        const part = await reader.read();
        const done = part.done;
        const value = part.value;
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        buffer = buffer.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        let splitAt = buffer.indexOf("\n\n");
        while (splitAt >= 0) {
          const chunk = buffer.slice(0, splitAt).trim();
          buffer = buffer.slice(splitAt + 2);
          splitAt = buffer.indexOf("\n\n");
          if (!chunk || chunk.startsWith(":")) {
            continue;
          }

          let eventName = "message";
          const dataLines = [];
          for (const line of chunk.split("\n")) {
            if (line.startsWith("event:")) {
              eventName = line.slice(6).trim() || "message";
            } else if (line.startsWith("data:")) {
              dataLines.push(line.slice(5).trimStart());
            }
          }
          if (!dataLines.length) {
            continue;
          }

          let payload = null;
          try {
            payload = JSON.parse(dataLines.join("\n"));
          } catch {
            continue;
          }

          if (eventName === "error") {
            throw new Error((payload && payload.message) || "SSE 返回错误");
          }

          const data = payload && payload.task ? payload : { task: payload };
          const task = data.task || {};
          applyPushInstallTaskState(task);
          lastData = data;
          if (data.done || eventName === "done" || isPushInstallTaskDone(task)) {
            return data;
          }
        }
      }

      if (lastData && isPushInstallTaskDone(lastData.task || {})) {
        return lastData;
      }
      throw new Error("SSE 已结束但任务未完成");
    }

    async function monitorPushInstallTaskByPolling(taskId) {
      const deadline = Date.now() + 30 * 60 * 1000;
      while (Date.now() < deadline) {
        const data = await queryPushInstallTask(taskId);
        const task = data.task || {};
        applyPushInstallTaskState(task);
        if (data.done || isPushInstallTaskDone(task)) {
          return data;
        }
        await new Promise((resolve) => setTimeout(resolve, 900));
      }
      throw new Error("安装任务超时，请稍后重试");
    }

    async function monitorPushInstallTask(taskId) {
      try {
        return await monitorPushInstallTaskBySSE(taskId);
      } catch (sseError) {
        showToast("SSE 连接失败，自动回退到轮询：" + (sseError.message || String(sseError)), "info");
        return await monitorPushInstallTaskByPolling(taskId);
      }
    }

    async function watchPushInstallTask(taskId) {
      if (pushInstallWatchPromise) {
        return pushInstallWatchPromise;
      }
      pushInstallRunning = true;
      pushInstallTaskId = String(taskId || "").trim();
      rememberPushInstallTask(pushInstallTaskId);
      setPushInstallButtonState();

      pushInstallWatchPromise = (async () => {
        let finalData = null;
        try {
          finalData = await monitorPushInstallTask(pushInstallTaskId);
        } catch (monitorError) {
          try {
            const fallback = await queryPushInstallTask(pushInstallTaskId);
            if (fallback && fallback.task && isPushInstallTaskDone(fallback.task)) {
              finalData = fallback;
            } else {
              throw monitorError;
            }
          } catch {
            throw monitorError;
          }
        }

        showJSON("box", { code: 0, message: "ok", data: finalData });
        const task = (finalData && finalData.task) || {};
        applyPushInstallTaskState(task);

        const status = String(task.status || "").toLowerCase();
        if (status === "succeeded") {
          const ffmpegPath = String(task.ffmpegPath || "").trim();
          if (ffmpegPath) {
            document.getElementById("pushFFmpegPathInput").value = ffmpegPath;
          }
          showToast("FFmpeg 安装完成：" + (ffmpegPath || "(未返回路径)"), "success");
          clearRememberedPushInstallTask();
          clearRememberedPushInstallTaskState();
          return finalData;
        }
        if (status === "cancelled") {
          showToast("已取消 FFmpeg 下载与安装", "info");
          clearRememberedPushInstallTask();
          clearRememberedPushInstallTaskState();
          return finalData;
        }
        if (status === "failed") {
          clearRememberedPushInstallTask();
          clearRememberedPushInstallTaskState();
          throw new Error(String(task.error || task.message || "FFmpeg 安装失败"));
        }

        return finalData;
      })();

      try {
        return await pushInstallWatchPromise;
      } finally {
        pushInstallWatchPromise = null;
        pushInstallRunning = false;
        pushInstallTaskId = "";
        setPushInstallButtonState();
      }
    }

    async function startPushInstallTask() {
      setPushFFmpegProgress(12, "正在创建安装任务...", "detect");
      const requestedPrefix = currentPushFFmpegCDNPrefix();
      const startResult = await requestJSON("/api/v1/config/ffmpeg/install", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ cdnPrefix: requestedPrefix })
      });
      const startData = (startResult && startResult.data) || {};
      const taskId = String(startData.taskId || "").trim();
      if (!taskId) {
        throw new Error("安装任务创建失败：缺少任务 ID");
      }
      rememberPushInstallTask(taskId);
      if (startData.task) {
        applyPushInstallTaskState(startData.task);
      } else {
        persistPushInstallTaskState({
          taskId,
          status: "pending",
          stage: "detect",
          percent: 12,
          message: "安装任务已创建",
          route: normalizePushInstallRouteLabel(requestedPrefix),
        });
      }
      showJSON("box", startResult);
      return taskId;
    }

    async function cancelPushInstallTask() {
      const taskId = String(pushInstallTaskId || getRememberedPushInstallTask()).trim();
      if (!taskId) {
        throw new Error("没有可取消的安装任务");
      }
      const result = await requestJSON("/api/v1/config/ffmpeg/install/cancel", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ taskId })
      });
      const data = (result && result.data) || {};
      if (data.task) {
        applyPushInstallTaskState(data.task);
      }
      showJSON("box", result);
      return result;
    }

    async function onPushInstallButtonClick() {
      if (pushInstallRunning) {
        await cancelPushInstallTask();
        return;
      }
      const taskId = await startPushInstallTask();
      await watchPushInstallTask(taskId);
    }

    async function resumePushInstallTaskIfNeeded() {
      const snapshotTaskId = restorePushInstallTaskState();
      const taskId = getRememberedPushInstallTask() || snapshotTaskId;
      if (!taskId) return;
      rememberPushInstallTask(taskId);
      try {
        const data = await queryPushInstallTask(taskId);
        const task = data.task || {};
        applyPushInstallTaskState(task);
        if (data.done || isPushInstallTaskDone(task)) {
          clearRememberedPushInstallTask();
          clearRememberedPushInstallTaskState();
          setPushInstallButtonState();
          return;
        }
        showToast("检测到未完成的 FFmpeg 安装任务，正在恢复进度...", "info");
        await watchPushInstallTask(taskId);
      } catch (error) {
        const msg = error.message || String(error);
        if (msg.includes("not found") || msg.includes("不存在") || msg.includes("install task")) {
          clearRememberedPushInstallTask();
          clearRememberedPushInstallTaskState();
        }
        setPushInstallButtonState();
        showToast("恢复任务失败：" + msg, "error");
      }
    }

    async function applySelectedCamera() {

      const id = Number(document.getElementById("cameraSelect").value || 0);
      if (!id) throw new Error("请先选择摄像头");
      const result = await requestJSON(`/api/v1/cameras/${id}/apply-push`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: "{}"
      });
      showJSON("box", result);
      if (result && result.data && result.data.pushSetting) {
        fillSetting(result.data.pushSetting);
        markFields([
          "inputType",
          "rtspUrl",
          "mjpegUrl",
          "rtmpUrl",
          "gbPullUrl",
          "onvifEndpoint",
          "onvifUsername",
          "onvifPassword",
          "onvifProfileToken",
          "onvifRtspUrl",
          "usbName",
          "usbResolution",
          "usbFramerate",
        ]);
        showToast("摄像头已套用到推流配置", "success");
      }
    }

    function fillSetting(item) {
      const data = item || {};
      document.getElementById("model").value = String(data.model || 1);
      document.getElementById("inputType").value = data.inputType || "video";
      document.getElementById("resolution").value = data.outputResolution || "1280x720";
      document.getElementById("quality").value = String(data.outputQuality || 2);
      applyBitratePresetFromValue(data.outputBitrateKbps || 0);
      document.getElementById("autoRetry").value = data.isAutoRetry ? "true" : "false";
      document.getElementById("retryInterval").value = String(data.retryInterval || 30);
      document.getElementById("sourceAudioEnabled").value = data.isMute ? "false" : "true";
      document.getElementById("ffmpegCommand").value = data.ffmpegCommand || "";
      document.getElementById("rtspUrl").value = data.rtspUrl || "";
      document.getElementById("mjpegUrl").value = data.mjpegUrl || "";
      document.getElementById("rtmpUrl").value = data.rtmpUrl || "";
      document.getElementById("gbPullUrl").value = data.gbPullUrl || "";
      document.getElementById("onvifEndpoint").value = data.onvifEndpoint || "";
      document.getElementById("onvifUsername").value = data.onvifUsername || "";
      document.getElementById("onvifPassword").value = data.onvifPassword || "";
      document.getElementById("onvifProfileToken").value = data.onvifProfileToken || "";
      document.getElementById("onvifRtspUrl").value = data.rtspUrl || "";
      document.getElementById("usbName").value = data.inputDeviceName || "";
      document.getElementById("usbResolution").value = data.inputDeviceResolution || "1280x720";
      document.getElementById("usbFramerate").value = String(data.inputDeviceFramerate || 30);
      setPendingMaterialSelection(Number(data.videoId || 0), Number(data.audioId || 0));
      document.getElementById("multiInputEnabled").value = data.multiInputEnabled ? "true" : "false";
      document.getElementById("multiInputLayout").value = data.multiInputLayout || "2x2";
      const fromMeta = Array.isArray(data.multiInputMeta) ? data.multiInputMeta : [];
      const fromURL = Array.isArray(data.multiInputUrls) ? data.multiInputUrls.map((url) => ({ url })) : [];
      mergeAndSetMultiInputSources(fromMeta.length ? fromMeta : fromURL);
      if (data.multiInputEnabled) {
        const hasAudioSource = multiInputSources.some((item) => item.enableAudio);
        document.getElementById("sourceAudioEnabled").value = hasAudioSource ? "true" : "false";
      }
      switchInputPanels();
      autoSuggestAdvancedCommand();
    }

    async function loadSetting() {
      const result = await requestJSON("/api/v1/push/setting");
      fillSetting(result.data || {});
      showJSON("box", result);
      await refreshPushStatus(true);
    }

    function buildPayload() {
      const inputType = asText("inputType") || "video";
      const videoId = Number(asText("videoMaterialSelect") || 0);
      const audioId = Number(asText("audioMaterialSelect") || 0);
      const multiInputEnabled = asBool("multiInputEnabled");
      const multiInputLayout = asText("multiInputLayout") || "2x2";
      const multiSources = collectMultiInputSourcesForPayload();
      if (multiInputEnabled && multiSources.length < 2) {
        throw new Error("启用拼屏时至少需要 2 路有效输入源");
      }
      if (inputType === "video" && videoId <= 0) {
        throw new Error("请先选择一个视频素材作为推流输入源");
      }
      const sourceAudioEnabled = asBool("sourceAudioEnabled");
      const hasMultiAudioSource = multiSources.some((item) => Boolean(item.enableAudio));
      const muteAll = multiInputEnabled ? !hasMultiAudioSource : !sourceAudioEnabled;
      const payload = {
        model: asNumber("model", 1),
        inputType,
        videoId,
        audioId,
        outputResolution: asText("resolution") || "1280x720",
        outputQuality: asNumber("quality", 2),
        outputBitrateKbps: currentBitrateKbps(),
        isAutoRetry: asBool("autoRetry"),
        retryInterval: asNumber("retryInterval", 30),
        isMute: muteAll,
        ffmpegCommand: document.getElementById("ffmpegCommand").value || "",
        rtspUrl: asText("rtspUrl"),
        mjpegUrl: asText("mjpegUrl"),
        rtmpUrl: asText("rtmpUrl"),
        gbPullUrl: asText("gbPullUrl"),
        onvifEndpoint: asText("onvifEndpoint"),
        onvifUsername: asText("onvifUsername"),
        onvifPassword: document.getElementById("onvifPassword").value || "",
        onvifProfileToken: asText("onvifProfileToken"),
        inputDeviceName: asText("usbName"),
        inputDeviceResolution: asText("usbResolution"),
        inputDeviceFramerate: asNumber("usbFramerate", 30),
        multiInputEnabled,
        multiInputLayout,
        multiInputMeta: multiSources,
        multiInputUrls: multiSources.map((item) => item.url),
      };
      if (inputType === "onvif") {
        payload.rtspUrl = asText("onvifRtspUrl");
      }
      return payload;
    }

    async function saveSetting() {
      const result = await requestJSON("/api/v1/push/setting", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(buildPayload())
      });
      showJSON("box", result);
    }

    async function startLocalPreview() {
      const saveResult = await requestJSON("/api/v1/push/setting", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(buildPayload())
      });
      showJSON("box", saveResult);
      if (saveResult && Number(saveResult.code) < 0) {
        throw new Error(saveResult.message || "推流配置保存失败，未启动本地预览");
      }

      const previewMode = asText("previewMode") || "auto";
      if (shouldUseWebRTCPreview()) {
        try {
          await startLocalPreviewWebRTC();
          return;
        } catch (error) {
          if (previewMode === "webrtc") {
            throw error;
          }
          showToast(`WebRTC 预览失败，自动回退 MJPEG：${error.message || String(error)}`, "info");
        }
      }

      const width = Math.max(240, Math.min(1920, asNumber("previewWidth", 960)));
      const fps = Math.max(1, Math.min(20, asNumber("previewFps", 10)));
      const img = document.getElementById("localPreviewImage");
      const video = document.getElementById("localPreviewVideo");
      localPreviewRunning = true;
      stopLocalPreviewPeer();
      video.pause();
      video.style.display = "none";
      video.srcObject = null;
      img.style.display = "block";
      img.onerror = () => {
        if (!localPreviewRunning) return;
        setLocalPreviewInfo("本地 MJPEG 预览失败，请检查输入源配置后重试。");
      };
      img.onload = () => {
        if (!localPreviewRunning) return;
        setLocalPreviewInfo("本地 MJPEG 预览中。");
      };
      img.src = `/api/v1/push/preview/mjpeg?width=${width}&fps=${fps}&_ts=${Date.now()}`;
      setLocalPreviewInfo("正在建立 MJPEG 本地预览连接...");
    }

    async function refreshPushStatus(quiet) {
      const result = await requestJSON("/api/v1/push/status");
      if (!quiet) {
        showJSON("box", result);
      }
      setPushStatusView(result && result.data ? result.data.status : 0);
      return result;
    }

    document.getElementById("inputType").onchange = () => {
      switchInputPanels();
      autoSuggestAdvancedCommand();
    };
    document.getElementById("videoMaterialSelect").onchange = updateMaterialHint;
    document.getElementById("audioMaterialSelect").onchange = updateMaterialHint;
    document.getElementById("model").onchange = autoSuggestAdvancedCommand;
    document.getElementById("resolution").onchange = () => {
      renderMultiInputCanvas();
    };
    document.getElementById("bitratePreset").onchange = syncBitrateCustomVisibility;
    document.getElementById("cameraFilterType").onchange = () => loadCameras().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    document.getElementById("pushFFmpegCdnPreset").onchange = updatePushFFmpegCdnCustomVisibility;
    document.getElementById("multiInputEnabled").onchange = () => {
      if (!asBool("multiInputEnabled")) {
        showToast("已关闭拼屏，推流将按单路输入源配置运行", "info");
      } else if (!multiInputSources.some((item) => item.enableAudio)) {
        document.getElementById("sourceAudioEnabled").value = "false";
      }
    };
    document.getElementById("sourceAudioEnabled").onchange = () => {
      if (!asBool("multiInputEnabled")) return;
      const enable = asBool("sourceAudioEnabled");
      if (!enable) {
        for (const item of multiInputSources) {
          item.enableAudio = false;
        }
      } else if (multiInputSources.length > 0 && !multiInputSources.some((item) => item.enableAudio)) {
        multiInputSources[0].enableAudio = true;
      }
      renderMultiInputList();
    };

    bindAction("load", loadSetting, "box", { successToast: false });
    bindAction("save", saveSetting, "box");
    bindAction("start", async () => {
      const result = await requestJSON("/api/v1/push/start", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
      showJSON("box", result);
      await refreshPushStatus(true);
      return result;
    }, "box");
    bindAction("stop", async () => {
      const result = await requestJSON("/api/v1/push/stop", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
      showJSON("box", result);
      await refreshPushStatus(true);
      return result;
    }, "box");
    bindAction("restart", async () => {
      const result = await requestJSON("/api/v1/push/restart", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
      showJSON("box", result);
      await refreshPushStatus(true);
      return result;
    }, "box");
    bindAction("status", () => refreshPushStatus(false), "box", { successToast: false });
    bindAction("btnLoadCameras", loadCameras, "box", { successToast: false });
    bindAction("btnApplyCamera", applySelectedCamera, "box");
    bindAction("btnLoadMaterialSources", loadMaterialSources, "box", { successToast: false });
    bindAction("btnOpenCameraPage", async () => {
      window.location.href = "/app/pages/cameras.html";
    }, "box");
    bindAction("btnAutoDetectFFmpegPush", autoDetectFFmpegPathForPush, "box", { successToast: false });
    bindAction("btnSaveFFmpegPathPush", saveFFmpegPathManuallyForPush, "box", { successToast: false });
    document.getElementById("btnInstallFFmpegPush").onclick = () => { onPushInstallButtonClick().catch((error) => { showToast(error.message || String(error), "error"); showJSON("box", { code: -1, message: error.message || String(error), data: error.payload || null }); }); };
    bindAction("btnFillAdvancedCmd", async () => {
      document.getElementById("ffmpegCommand").value = recommendedAdvancedCommand(asText("inputType"));
      showJSON("box", { code: 0, message: "已按当前输入类型填充推荐高级命令" });
    }, "box");
    bindAction("btnStartLocalPreview", startLocalPreview, "box");
    bindAction("btnStopLocalPreview", async () => {
      stopLocalPreview();
      showJSON("box", { code: 0, message: "已关闭本地预览" });
    }, "box");
    bindAction("btnMultiInputAddSelected", async () => {
      const result = addSelectedCamerasToMultiInput();
      if (!result.added && result.skipped) {
        throw new Error("所选摄像头未能添加（可能缺少可拉流地址或已存在）");
      }
      showJSON("box", { code: 0, message: `拼屏源新增 ${result.added} 路，跳过 ${result.skipped} 路` });
      return { code: 0, message: `已添加 ${result.added} 路` };
    }, "box");
    bindAction("btnMultiInputAddManual", async () => {
      addManualMultiInputSource();
      showJSON("box", { code: 0, message: "已添加手动拼屏源" });
      return { code: 0, message: "已添加手动拼屏源" };
    }, "box");
    bindAction("btnMultiInputAutoLayout", async () => {
      if (!multiInputSources.length) {
        throw new Error("no mosaic source to layout");
      }
      autoLayoutMultiInput(multiInputSources);
      document.getElementById("multiInputLayout").value = "canvas";
      renderMultiInputList();
      renderMultiInputCanvas();
      showJSON("box", { code: 0, message: "已完成自动排布，并切换为画布模式" });
      return { code: 0, message: "已完成自动排布" };
    }, "box");
    bindAction("btnMultiInputClear", async () => {
      const ok = await showConfirm("清空拼屏源", "确定清空全部拼屏源吗？");
      if (!ok) {
        return { code: 0, message: "已取消" };
      }
      multiInputSources = [];
      document.getElementById("sourceAudioEnabled").value = "false";
      renderMultiInputList();
      renderMultiInputCanvas();
      showJSON("box", { code: 0, message: "已清空拼屏源" });
      return { code: 0, message: "已清空拼屏源" };
    }, "box");
    bindAction("btnOpenAdvancedConsole", async () => {
      window.open("/app/index.html", "_blank", "noopener");
      return { code: 0, message: "已打开高级控制台" };
    }, "box");

    window.addEventListener("beforeunload", () => {
      stopLocalPreviewPeer();
    });

    switchInputPanels();
    applyBitratePresetFromValue(0);
    renderMultiInputList();
    renderMultiInputCanvas();
    stopLocalPreview();
    updatePushFFmpegCdnCustomVisibility();
    setPushInstallButtonState();
    setPushInstallTaskLabel(getRememberedPushInstallTask());
    const pushInstallSnapshot = getRememberedPushInstallTaskState();
    setPushInstallRouteLabel((pushInstallSnapshot && pushInstallSnapshot.route) || "");
    loadFFmpegPathInputForPush().catch(() => {});
    resumePushInstallTaskIfNeeded().catch(() => {});
    loadSetting().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    loadCameras().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    loadMaterialSources().catch((error) => showJSON("box", { code: -1, message: error.message || String(error) }));
    const statusPoller = createPoller(() => refreshPushStatus(true), 5000);
    statusPoller.start();
  </script>
</body>
</html>
