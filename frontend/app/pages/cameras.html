<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>摄像头管理</title>
  <link rel="stylesheet" href="/app/pages/shared.css" />
</head>
<body>
  <header class="shared-header">
    <div id="sharedNav"></div>
  </header>
  <main class="page-shell">
    <section class="page-card">
      <h1>摄像头管理</h1>
      <p class="soft-note">按普通用户流程：先发现设备 → 补充账号密码 → 一键保存 → 推流/拼屏直接复用。</p>
      <div id="roleTip" class="role-tip"></div>
      <div class="stepper">
        <div id="cameraStep0" class="stepper-item active">
          <span>0. 扫描 FFmpeg</span>
          <span class="badge badge-info">进行中</span>
        </div>
        <div id="cameraStep1" class="stepper-item">
          <span>1. 发现设备</span>
          <span class="badge badge-neutral">待完成</span>
        </div>
        <div id="cameraStep2" class="stepper-item">
          <span>2. 保存到库</span>
          <span class="badge badge-neutral">待完成</span>
        </div>
        <div id="cameraStep3" class="stepper-item">
          <span>3. 套用推流</span>
          <span class="badge badge-neutral">待完成</span>
        </div>
      </div>
    </section>

    <section class="page-card">
      <h2>0. FFmpeg 检测与安装</h2>
      <div class="grid two">
        <label>FFmpeg 路径（可手动输入）
          <input id="cameraFFmpegPathInput" placeholder="Windows 示例: C:\path\to\ffmpeg.exe 或 C:\path\to\目录；Linux 示例: /opt/ffmpeg/ffmpeg 或 /opt/ffmpeg" />
        </label>
        <label>CDN 加速预设
          <select id="cameraFFmpegCdnPreset">
            <option value="">不使用（直连 GitHub）</option>
            <option value="https://gh-proxy.org/" selected>gh-proxy.org</option>
            <option value="https://hk.gh-proxy.org/">hk.gh-proxy.org</option>
            <option value="https://gitproxy.click/">gitproxy.click</option>
            <option value="__custom__">自定义</option>
          </select>
        </label>
      </div>
      <div id="cameraFFmpegCdnCustomWrap" class="panel-hidden">
        <label>自定义 CDN 前缀
          <input id="cameraFFmpegCdnCustom" placeholder="例如：https://gh-proxy.org/" />
        </label>
      </div>
      <div class="actions">
        <button id="btnAutoDetectFFmpeg">扫描并自动保存 FFmpeg 路径</button>
        <button id="btnInstallFFmpegCamera">自动下载并安装 FFmpeg</button>
        <button id="btnSaveFFmpegPath">保存手动输入的 FFmpeg 路径</button>
      </div>
      <div class="upload-progress">
        <div class="progress-bar"><span id="cameraFFmpegProgressValue" class="progress-value"></span></div>
        <div id="cameraFFmpegProgressText" class="soft-note">等待执行 FFmpeg 检测或安装任务</div>
        <div id="cameraFFmpegStageList" class="ffmpeg-stage-list">
          <span class="badge badge-neutral" data-stage="detect">检测</span>
          <span class="badge badge-neutral" data-stage="download">下载</span>
          <span class="badge badge-neutral" data-stage="extract">解压</span>
          <span class="badge badge-neutral" data-stage="verify">校验</span>
          <span class="badge badge-neutral" data-stage="save">保存</span>
        </div>
      </div>
      <p class="soft-note">自动扫描会保存并回填；扫描不到时可手动输入并保存，也可自动下载安装到 data 目录（压缩包会自动清理）。</p>
    </section>

    <section class="page-card">
      <h2>一步发现设备</h2>
      <div class="grid two">
        <label>发现到的 ONVIF 设备
          <select id="discoveredOnvifList">
            <option value="">（点击“扫描 ONVIF”后可选择）</option>
          </select>
        </label>
        <label>本机 USB 摄像头
          <select id="discoveredUsbList">
            <option value="">（点击“读取 USB 列表”后可选择）</option>
          </select>
        </label>
      </div>
      <div class="grid two">
        <label>ONVIF Endpoint（可手动填写）
          <input id="onvifQuickEndpoint" placeholder="http://ip/onvif/device_service" />
        </label>
        <label>ONVIF 用户名
          <input id="onvifQuickUsername" placeholder="admin" />
        </label>
      </div>
      <div class="grid two">
        <label>ONVIF 密码
          <input id="onvifQuickPassword" type="text" placeholder="123456" />
        </label>
        <label>提示
          <input value="先填账号密码再读取 Profiles，可自动回填 RTSP 到“绑定 RTSP 地址”" readonly />
        </label>
      </div>
      <div class="actions">
        <button id="btnDiscoverOnvif">扫描 ONVIF（局域网）</button>
        <button id="btnProbeOnvifProfiles">读取 ONVIF 配置档</button>
        <button id="btnDiscoverUsb">读取 USB 列表</button>
      </div>
    </section>

    <section class="page-card">
      <h2>二步保存到摄像头库</h2>
      <input id="cameraId" type="hidden" />
      <div class="grid two">
        <label>名称（好记即可）
          <input id="cameraName" placeholder="例如：客厅主机位 / 门口摄像头" />
        </label>
        <label>类型
          <select id="cameraType">
            <option value="rtsp">RTSP</option>
            <option value="mjpeg">MJPEG</option>
            <option value="rtmp">RTMP</option>
            <option value="gb28181">GB28181</option>
            <option value="onvif">ONVIF</option>
            <option value="usb">USB 摄像头</option>
          </select>
        </label>
      </div>
      <div class="grid two">
        <label>启用状态
          <select id="cameraEnabled">
            <option value="true" selected>启用</option>
            <option value="false">停用</option>
          </select>
        </label>
        <label>备注（可选）
          <input id="cameraDescription" placeholder="例如：夜间码率降低到 2M" />
        </label>
      </div>

      <div id="panelRTSP" class="soft-panel">
        <h3>RTSP 配置</h3>
        <label>RTSP 地址
          <input id="cameraRtspUrl" placeholder="rtsp://user:pass@ip/stream" />
        </label>
      </div>

      <div id="panelMJPEG" class="soft-panel panel-hidden">
        <h3>MJPEG 配置</h3>
        <label>MJPEG 地址
          <input id="cameraMjpegUrl" placeholder="http://ip:port/mjpeg" />
        </label>
      </div>

      <div id="panelRTMP" class="soft-panel panel-hidden">
        <h3>RTMP 配置</h3>
        <label>RTMP 地址
          <input id="cameraRtmpUrl" placeholder="rtmp://ip/app/stream" />
        </label>
      </div>

      <div id="panelGB28181" class="soft-panel panel-hidden">
        <h3>GB28181 设备配置</h3>
        <label>拉流地址（必填）
          <input id="cameraGbPullUrl" placeholder="rtsp://zlm/live/340200... 或 http://.../live.flv" />
        </label>
        <div class="grid two">
          <label>设备 ID（可选）
            <input id="cameraGbDeviceId" placeholder="34020000001320000001" />
          </label>
          <label>通道 ID（可选）
            <input id="cameraGbChannelId" placeholder="34020000001310000001" />
          </label>
        </div>
        <div class="grid two">
          <label>平台地址（可选）
            <input id="cameraGbServer" placeholder="192.168.1.100:5060" />
          </label>
          <label>传输协议
            <select id="cameraGbTransport">
              <option value="udp">UDP</option>
              <option value="tcp">TCP</option>
            </select>
          </label>
        </div>
      </div>

      <div id="panelONVIF" class="soft-panel panel-hidden">
        <h3>ONVIF 配置（每台设备可独立用户名/密码）</h3>
        <div class="grid two">
          <label>ONVIF Endpoint
            <input id="cameraOnvifEndpoint" placeholder="http://ip/onvif/device_service" />
          </label>
          <label>ProfileToken（可选）
            <input id="cameraOnvifProfileToken" placeholder="可从“读取 ONVIF 配置档”获得" />
          </label>
        </div>
        <div class="grid two">
          <label>用户名
            <input id="cameraOnvifUsername" placeholder="admin" />
          </label>
          <label>密码（明文保存）
            <input id="cameraOnvifPassword" type="text" placeholder="123456" />
          </label>
        </div>
        <label>绑定 RTSP 地址（用于推流）
          <input id="cameraOnvifRtspUrl" placeholder="rtsp://user:pass@ip/stream" />
        </label>
      </div>

      <div id="panelUSB" class="soft-panel panel-hidden">
        <h3>USB 摄像头配置</h3>
        <div class="grid two">
          <label>设备名（快速选择）
            <select id="cameraUsbNameSelect">
              <option value="">（读取 USB 列表后可选择）</option>
              <option value="__manual__">其他（手动输入）</option>
            </select>
          </label>
          <label id="cameraUsbNameManualWrap" style="display:none;">手动输入设备名
            <input id="cameraUsbName" placeholder="HD Pro Webcam C920 或 /dev/video0" />
          </label>
        </div>
        <div class="grid two">
          <label>分辨率
            <input id="cameraUsbResolution" value="1280x720" />
          </label>
          <label>帧率（fps）
            <input id="cameraUsbFps" type="number" value="30" />
          </label>
        </div>
      </div>

      <div class="actions">
        <button id="btnCameraNew">新建</button>
        <button id="btnCameraSave">保存到摄像头库</button>
        <button id="btnCameraDelete">删除当前</button>
        <button id="btnCameraApplyPush">一键套用到推流配置</button>
      </div>

      <div class="soft-panel">
        <h3>按需画面预览（节省资源）</h3>
        <p class="soft-note">仅在你点击“开启预览”时才会占用资源；关闭预览会立即断开。</p>
        <div class="grid two">
          <label>预览宽度（px）
            <input id="cameraPreviewWidth" type="number" value="640" min="240" max="1920" />
          </label>
          <label>预览帧率（fps）
            <input id="cameraPreviewFps" type="number" value="8" min="1" max="20" />
          </label>
        </div>
        <div class="grid two">
          <label>预览协议
            <select id="cameraPreviewMode">
              <option value="auto" selected>自动（RTSP/ONVIF 优先 WebRTC）</option>
              <option value="webrtc">WebRTC</option>
              <option value="mjpeg">MJPEG</option>
            </select>
          </label>
          <label>说明
            <input value="RTSP/ONVIF 通常建议优先 WebRTC，延迟更低更流畅。" readonly />
          </label>
        </div>
        <div class="actions">
          <button id="btnCameraPreviewStart">开启预览</button>
          <button id="btnCameraPreviewStop">关闭预览</button>
        </div>
        <div class="preview-panel">
          <img id="cameraPreviewImage" alt="摄像头预览画面" />
          <video id="cameraPreviewVideo" autoplay muted playsinline controls></video>
          <div id="cameraPreviewInfo" class="soft-note">请先从下方列表选择已保存的摄像头，再开启预览。</div>
        </div>
      </div>
    </section>

    <section class="page-card">
      <h2>三步复用（推流 / 拼屏）</h2>
      <p class="soft-note">保存后可在本页列表中快速选择，也可在推流页和高级控制台拼屏区直接调用。</p>
      <div class="grid two">
        <label>关键词
          <input id="cameraKeyword" placeholder="名称 / 地址 / 设备名" />
        </label>
        <label>类型筛选
          <select id="cameraFilterType">
            <option value="">全部</option>
            <option value="rtsp">RTSP</option>
            <option value="mjpeg">MJPEG</option>
            <option value="rtmp">RTMP</option>
            <option value="gb28181">GB28181</option>
            <option value="onvif">ONVIF</option>
            <option value="usb">USB</option>
          </select>
        </label>
      </div>
      <div class="grid two">
        <label>页码
          <input id="cameraPage" type="number" value="1" />
        </label>
        <label>每页数量
          <input id="cameraLimit" type="number" value="20" />
        </label>
      </div>
      <div class="actions">
        <button id="btnCameraList">刷新列表</button>
      </div>
      <div class="table-wrap">
        <table id="cameraTable">
          <thead>
            <tr>
              <th>ID</th>
              <th>名称</th>
              <th>类型</th>
              <th>主要地址/设备</th>
              <th>状态</th>
              <th>更新时间</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <pre id="cameraBox">{}</pre>
    </section>
  </main>

  <script src="/app/pages/shared.js"></script>
  <script>
    const { initPage, requestJSON, showJSON, bindAction, showConfirm, statusBadge, markFields, setPanelVisible, showToast } = window.GoverShared;
    initPage({ active: "cameras" });

    const rowsCache = new Map();
    let cameraPreviewRunning = false;
    let cameraPreviewPeer = null;
    let cameraPreviewSessionId = "";
    let editingCameraId = 0;
    let flashCameraId = 0;
    let onvifAutoProbeTimer = null;
    let onvifLastProbeKey = "";
    const USB_NAME_MANUAL_OPTION = "__manual__";

    function boolValue(id) {
      return String(document.getElementById(id).value || "").toLowerCase() === "true";
    }

    function numberValue(id, fallback) {
      const value = Number(document.getElementById(id).value || 0);
      if (!Number.isFinite(value)) return fallback;
      return value;
    }

    function textValue(id) {
      return String(document.getElementById(id).value || "").trim();
    }

    const CAMERA_FFMPEG_STAGE_ORDER = ["detect", "download", "extract", "verify", "save"];

    function setCameraFFmpegProgress(progress, message, stage) {
      const percent = Math.max(0, Math.min(100, Number(progress || 0)));
      const bar = document.getElementById("cameraFFmpegProgressValue");
      const text = document.getElementById("cameraFFmpegProgressText");
      if (bar) {
        bar.style.width = `${percent}%`;
      }
      if (text) {
        text.textContent = String(message || "").trim() || "...";
      }
      const wrap = document.getElementById("cameraFFmpegStageList");
      if (!wrap) return;
      const active = String(stage || "").trim();
      const activeIndex = CAMERA_FFMPEG_STAGE_ORDER.indexOf(active);
      wrap.querySelectorAll("[data-stage]").forEach((node) => {
        const key = String(node.getAttribute("data-stage") || "").trim();
        const idx = CAMERA_FFMPEG_STAGE_ORDER.indexOf(key);
        node.classList.remove("badge-success", "badge-info", "badge-neutral");
        if (percent >= 100) {
          node.classList.add("badge-success");
        } else if (activeIndex >= 0 && idx < activeIndex) {
          node.classList.add("badge-success");
        } else if (activeIndex >= 0 && idx == activeIndex) {
          node.classList.add("badge-info");
        } else {
          node.classList.add("badge-neutral");
        }
      });
    }

    function applyCameraFFmpegProgressList(list) {
      const steps = Array.isArray(list) ? list : [];
      if (!steps.length) return;
      let progress = 0;
      let message = "";
      let stage = "";
      for (const step of steps) {
        const p = Number((step && step.progress) || 0);
        if (Number.isFinite(p)) progress = Math.max(progress, p);
        if (step && step.message) message = String(step.message || "").trim() || message;
        if (step && step.stage) stage = String(step.stage || "").trim() || stage;
      }
      setCameraFFmpegProgress(progress, message || "ok", stage || "detect");
    }

    function updateCameraFFmpegCdnCustomVisibility() {
      const value = textValue("cameraFFmpegCdnPreset");
      setPanelVisible("cameraFFmpegCdnCustomWrap", value === "__custom__");
    }

    function currentCameraFFmpegCDNPrefix() {
      const value = textValue("cameraFFmpegCdnPreset");
      if (value === "__custom__") {
        return textValue("cameraFFmpegCdnCustom");
      }
      return value;
    }

    function fillUsbDeviceNameSelect(names) {
      const select = document.getElementById("cameraUsbNameSelect");
      if (!select) return;
      const currentName = currentUsbDeviceName();
      const normalized = [];
      const seen = new Set();
      for (const raw of Array.isArray(names) ? names : []) {
        const name = String(raw || "").trim();
        if (!name || seen.has(name)) continue;
        seen.add(name);
        normalized.push(name);
      }
      select.innerHTML = '<option value="">（请选择 USB 摄像头）</option>';
      for (const name of normalized) {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
      }
      const otherOpt = document.createElement("option");
      otherOpt.value = USB_NAME_MANUAL_OPTION;
      otherOpt.textContent = "其他（手动输入）";
      select.appendChild(otherOpt);
      setUsbDeviceNameValue(currentName);
    }

    function currentUsbDeviceName() {
      const selected = textValue("cameraUsbNameSelect");
      if (selected && selected !== USB_NAME_MANUAL_OPTION) {
        return selected;
      }
      return textValue("cameraUsbName");
    }

    function setUsbDeviceNameValue(name) {
      const value = String(name || "").trim();
      const select = document.getElementById("cameraUsbNameSelect");
      const manualInput = document.getElementById("cameraUsbName");
      if (!select || !manualInput) return;
      manualInput.value = value;
      if (!value) {
        select.value = "";
        updateUsbDeviceNameMode();
        return;
      }
      const exists = Array.from(select.options).some((opt) => opt.value === value);
      if (exists) {
        select.value = value;
      } else {
        select.value = USB_NAME_MANUAL_OPTION;
      }
      updateUsbDeviceNameMode();
      if (select.value !== USB_NAME_MANUAL_OPTION) {
        manualInput.value = select.value;
      }
    }

    function updateUsbDeviceNameMode() {
      const select = document.getElementById("cameraUsbNameSelect");
      const manualWrap = document.getElementById("cameraUsbNameManualWrap");
      const manualInput = document.getElementById("cameraUsbName");
      if (!select || !manualWrap || !manualInput) return;
      const manual = select.value === USB_NAME_MANUAL_OPTION;
      manualWrap.style.display = manual ? "" : "none";
      if (!manual && select.value) {
        manualInput.value = select.value;
      }
    }

    function syncQuickToOnvifForm(preferQuick) {
      const quickEndpoint = textValue("onvifQuickEndpoint");
      const quickUsername = textValue("onvifQuickUsername");
      const quickPassword = String(document.getElementById("onvifQuickPassword").value || "");
      const endpointInput = document.getElementById("cameraOnvifEndpoint");
      const usernameInput = document.getElementById("cameraOnvifUsername");
      const passwordInput = document.getElementById("cameraOnvifPassword");
      if (quickEndpoint && (preferQuick || !textValue("cameraOnvifEndpoint"))) {
        endpointInput.value = quickEndpoint;
      }
      if (quickUsername && (preferQuick || !textValue("cameraOnvifUsername"))) {
        usernameInput.value = quickUsername;
      }
      if (quickPassword && (preferQuick || !(passwordInput.value || ""))) {
        passwordInput.value = quickPassword;
      }
    }

    function syncOnvifFormToQuick() {
      const endpoint = textValue("cameraOnvifEndpoint");
      const username = textValue("cameraOnvifUsername");
      const password = String(document.getElementById("cameraOnvifPassword").value || "");
      if (endpoint) document.getElementById("onvifQuickEndpoint").value = endpoint;
      if (username) document.getElementById("onvifQuickUsername").value = username;
      if (password) document.getElementById("onvifQuickPassword").value = password;
    }

    function sourceTypeOf(item) {
      return String((item && item.sourceType) || "").toLowerCase();
    }

    function streamHint(item) {
      if (!item) return "";
      const type = sourceTypeOf(item);
      if (type === "rtsp" || type === "onvif") return item.rtspUrl || item.onvifEndpoint || "";
      if (type === "mjpeg") return item.mjpegUrl || "";
      if (type === "rtmp") return item.rtmpUrl || "";
      if (type === "gb28181") return item.gbPullUrl || item.gbDeviceId || "";
      if (type === "usb") return item.usbDeviceName || "";
      return "";
    }

    function switchTypePanels() {
      const type = textValue("cameraType");
      setPanelVisible("panelRTSP", type === "rtsp");
      setPanelVisible("panelMJPEG", type === "mjpeg");
      setPanelVisible("panelRTMP", type === "rtmp");
      setPanelVisible("panelGB28181", type === "gb28181");
      setPanelVisible("panelONVIF", type === "onvif");
      setPanelVisible("panelUSB", type === "usb");
      if (type === "onvif") {
        scheduleOnvifAutoProbe();
      }
    }

    function fillForm(item) {
      const data = item || {};
      document.getElementById("cameraId").value = data.id || "";
      editingCameraId = Number(data.id || 0);
      document.getElementById("cameraName").value = data.name || "";
      document.getElementById("cameraType").value = sourceTypeOf(data) || "rtsp";
      document.getElementById("cameraEnabled").value = data.enabled === false ? "false" : "true";
      document.getElementById("cameraDescription").value = data.description || "";
      document.getElementById("cameraRtspUrl").value = data.rtspUrl || "";
      document.getElementById("cameraMjpegUrl").value = data.mjpegUrl || "";
      document.getElementById("cameraRtmpUrl").value = data.rtmpUrl || "";
      document.getElementById("cameraGbPullUrl").value = data.gbPullUrl || "";
      document.getElementById("cameraGbDeviceId").value = data.gbDeviceId || "";
      document.getElementById("cameraGbChannelId").value = data.gbChannelId || "";
      document.getElementById("cameraGbServer").value = data.gbServer || "";
      document.getElementById("cameraGbTransport").value = data.gbTransport || "udp";
      document.getElementById("cameraOnvifEndpoint").value = data.onvifEndpoint || "";
      document.getElementById("cameraOnvifUsername").value = data.onvifUsername || "";
      document.getElementById("cameraOnvifPassword").value = data.onvifPassword || "";
      document.getElementById("cameraOnvifProfileToken").value = data.onvifProfileToken || "";
      const onvifRtspInput = document.getElementById("cameraOnvifRtspUrl");
      onvifRtspInput.value = data.rtspUrl || "";
      onvifRtspInput.dataset.autoFilled = "0";
      syncOnvifFormToQuick();
      setUsbDeviceNameValue(data.usbDeviceName || "");
      document.getElementById("cameraUsbResolution").value = data.usbDeviceResolution || "1280x720";
      document.getElementById("cameraUsbFps").value = String(data.usbDeviceFramerate || 30);
      switchTypePanels();
      renderTable({ data: Array.from(rowsCache.values()) });
      markFields(["cameraName", "cameraType"]);
    }

    function collectPayload() {
      syncQuickToOnvifForm(false);
      const id = numberValue("cameraId", 0);
      return {
        id: id > 0 ? id : 0,
        name: textValue("cameraName"),
        sourceType: textValue("cameraType"),
        enabled: boolValue("cameraEnabled"),
        description: textValue("cameraDescription"),
        rtspUrl: textValue("cameraType") === "onvif" ? textValue("cameraOnvifRtspUrl") : textValue("cameraRtspUrl"),
        mjpegUrl: textValue("cameraMjpegUrl"),
        rtmpUrl: textValue("cameraRtmpUrl"),
        gbPullUrl: textValue("cameraGbPullUrl"),
        gbDeviceId: textValue("cameraGbDeviceId"),
        gbChannelId: textValue("cameraGbChannelId"),
        gbServer: textValue("cameraGbServer"),
        gbTransport: textValue("cameraGbTransport") || "udp",
        onvifEndpoint: textValue("cameraOnvifEndpoint"),
        onvifUsername: textValue("cameraOnvifUsername"),
        onvifPassword: document.getElementById("cameraOnvifPassword").value || "",
        onvifProfileToken: textValue("cameraOnvifProfileToken"),
        usbDeviceName: currentUsbDeviceName(),
        usbDeviceResolution: textValue("cameraUsbResolution"),
        usbDeviceFramerate: numberValue("cameraUsbFps", 30)
      };
    }

    function resetForm(type) {
      stopCameraPreview();
      editingCameraId = 0;
      fillForm({
        id: 0,
        sourceType: type || textValue("cameraType") || "rtsp",
        enabled: true,
        usbDeviceResolution: "1280x720",
        usbDeviceFramerate: 30
      });
    }

    function renderTable(pageResult) {
      const body = document.querySelector("#cameraTable tbody");
      body.innerHTML = "";
      rowsCache.clear();
      const rows = (pageResult && pageResult.data) || [];
      if (!rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="7"><div class="table-empty">暂无摄像头，请先在上方填写后点击“保存到摄像头库”。</div></td>';
        body.appendChild(tr);
        return;
      }
      for (const item of rows) {
        rowsCache.set(item.id, item);
        const tr = document.createElement("tr");
        if (Number(item.id) === editingCameraId) {
          tr.classList.add("row-editing");
        }
        if (Number(item.id) === flashCameraId) {
          tr.classList.add("row-updated");
        }
        const stateBadge = item.enabled ? statusBadge("启用", "success") : statusBadge("停用", "neutral");
        tr.innerHTML = `
          <td>${item.id}</td>
          <td>${item.name || ""}</td>
          <td>${item.sourceType || ""}</td>
          <td>${streamHint(item) || ""}</td>
          <td>${stateBadge}</td>
          <td>${item.updatedAt || ""}</td>
          <td><button data-id="${item.id}" class="btn-mini">编辑</button></td>
        `;
        body.appendChild(tr);
      }
      body.querySelectorAll("button[data-id]").forEach((btn) => {
        btn.onclick = () => {
          const id = Number(btn.getAttribute("data-id"));
          const item = rowsCache.get(id);
          stopCameraPreview();
          setStepState(2, false);
          fillForm(item || {});
        };
      });
    }

    function setStepState(step, done) {
      const target = document.getElementById(`cameraStep${step}`);
      if (!target) return;
      target.classList.remove("active", "done");
      const badge = target.querySelector(".badge");
      if (done) {
        target.classList.add("done");
        if (badge) {
          badge.className = "badge badge-success";
          badge.textContent = "已完成";
        }
      } else {
        target.classList.add("active");
        if (badge) {
          badge.className = "badge badge-info";
          badge.textContent = "进行中";
        }
      }
    }

    function setPreviewInfo(text) {
      document.getElementById("cameraPreviewInfo").textContent = text || "";
    }

    function isRTSPLike(value) {
      const text = String(value || "").trim().toLowerCase();
      return text.startsWith("rtsp://") || text.startsWith("rtsps://");
    }

    function shouldUseCameraWebRTC(item) {
      const mode = textValue("cameraPreviewMode") || "auto";
      if (mode === "webrtc") return true;
      if (mode === "mjpeg") return false;
      const sourceType = sourceTypeOf(item) || textValue("cameraType");
      if (sourceType === "rtsp" || sourceType === "onvif") return true;
      if (sourceType === "gb28181") {
        const gbPullURL = String((item && item.gbPullUrl) || textValue("cameraGbPullUrl") || "").trim();
        return isRTSPLike(gbPullURL);
      }
      return false;
    }

    function waitForICEGatheringComplete(peer) {
      if (!peer || peer.iceGatheringState === "complete") {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        const onState = () => {
          if (peer.iceGatheringState === "complete") {
            peer.removeEventListener("icegatheringstatechange", onState);
            resolve();
          }
        };
        peer.addEventListener("icegatheringstatechange", onState);
      });
    }

    function stopCameraPreviewPeer() {
      if (cameraPreviewPeer) {
        try {
          cameraPreviewPeer.ontrack = null;
          cameraPreviewPeer.onconnectionstatechange = null;
          cameraPreviewPeer.close();
        } catch (_) {
          // Ignore close errors.
        }
      }
      cameraPreviewPeer = null;
      if (cameraPreviewSessionId) {
        requestJSON("/api/v1/push/preview/webrtc/close", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sessionId: cameraPreviewSessionId }),
        }).catch(() => {});
      }
      cameraPreviewSessionId = "";
    }

    function stopCameraPreview() {
      const img = document.getElementById("cameraPreviewImage");
      const video = document.getElementById("cameraPreviewVideo");
      if (!img || !video) return;
      cameraPreviewRunning = false;
      stopCameraPreviewPeer();
      img.style.display = "none";
      img.src = "";
      video.pause();
      video.style.display = "none";
      video.srcObject = null;
      setPreviewInfo("预览已关闭。");
    }

    function startCameraPreviewMJPEG(id) {
      const width = Math.max(240, Math.min(1920, numberValue("cameraPreviewWidth", 640)));
      const fps = Math.max(1, Math.min(20, numberValue("cameraPreviewFps", 8)));
      const img = document.getElementById("cameraPreviewImage");
      const video = document.getElementById("cameraPreviewVideo");
      stopCameraPreviewPeer();
      cameraPreviewRunning = true;
      video.pause();
      video.style.display = "none";
      video.srcObject = null;
      img.style.display = "block";
      img.onerror = () => {
        if (!cameraPreviewRunning) return;
        setPreviewInfo("预览连接失败，请检查地址/账号密码/网络后重试。");
      };
      img.onload = () => {
        if (!cameraPreviewRunning) return;
        setPreviewInfo("预览中（关闭后立即释放资源）");
      };
      img.src = `/api/v1/cameras/${id}/preview/mjpeg?width=${width}&fps=${fps}&_ts=${Date.now()}`;
      setPreviewInfo("正在建立预览连接...");
    }

    async function startCameraPreviewWebRTC(id) {
      const img = document.getElementById("cameraPreviewImage");
      const video = document.getElementById("cameraPreviewVideo");
      stopCameraPreviewPeer();
      img.style.display = "none";
      img.src = "";

      const peer = new RTCPeerConnection({ iceServers: [] });
      try {
        cameraPreviewPeer = peer;
        const stream = new MediaStream();
        video.srcObject = stream;
        video.style.display = "block";
        cameraPreviewRunning = true;
        setPreviewInfo("正在建立 WebRTC 预览连接...");

        peer.ontrack = (event) => {
          const tracks = event.streams && event.streams[0] ? event.streams[0].getTracks() : [event.track];
          for (const track of tracks) {
            if (stream.getTracks().find((item) => item.id === track.id)) continue;
            stream.addTrack(track);
          }
        };

        peer.onconnectionstatechange = () => {
          if (!cameraPreviewRunning) return;
          const state = peer.connectionState;
          if (state === "connected") {
            setPreviewInfo("WebRTC 预览已连接。");
          } else if (state === "failed" || state === "disconnected" || state === "closed") {
            setPreviewInfo(`WebRTC 连接状态：${state}`);
          }
        };

        const offer = await peer.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: true });
        await peer.setLocalDescription(offer);
        await waitForICEGatheringComplete(peer);
        const local = peer.localDescription;
        if (!local || !local.sdp) {
          throw new Error("WebRTC 本地 offer 为空");
        }

        const result = await requestJSON(`/api/v1/cameras/${id}/preview/webrtc/offer`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ type: local.type || "offer", sdp: local.sdp }),
        });
        const answer = result && result.data ? result.data : {};
        if (!answer.sdp) {
          throw new Error("WebRTC answer 为空");
        }
        await peer.setRemoteDescription({
          type: answer.type || "answer",
          sdp: answer.sdp,
        });
        cameraPreviewSessionId = String(answer.sessionId || "").trim();
        try {
          await video.play();
        } catch (_) {
          // Browser autoplay policies may block auto play.
        }
      } catch (error) {
        stopCameraPreview();
        throw error;
      }
    }

    async function startCameraPreview() {
      const id = numberValue("cameraId", 0);
      if (!id) throw new Error("请先在列表选择一个已保存摄像头，再开启预览");
      const selected = rowsCache.get(id) || null;
      const mode = textValue("cameraPreviewMode") || "auto";
      if (shouldUseCameraWebRTC(selected)) {
        try {
          await startCameraPreviewWebRTC(id);
          return;
        } catch (error) {
          if (mode === "webrtc") {
            throw error;
          }
          showToast(`WebRTC 预览失败，自动回退 MJPEG：${error.message || String(error)}`, "info");
        }
      }
      startCameraPreviewMJPEG(id);
    }

    async function loadList() {
      const page = numberValue("cameraPage", 1);
      const limit = numberValue("cameraLimit", 20);
      const params = new URLSearchParams();
      params.set("page", String(page > 0 ? page : 1));
      params.set("limit", String(limit > 0 ? limit : 20));
      const keyword = textValue("cameraKeyword");
      if (keyword) params.set("keyword", keyword);
      const type = textValue("cameraFilterType");
      if (type) params.set("sourceType", type);
      const result = await requestJSON(`/api/v1/cameras?${params.toString()}`);
      renderTable(result.data || {});
      showJSON("cameraBox", result);
    }

    async function saveCamera() {
      const payload = collectPayload();
      const result = await requestJSON("/api/v1/cameras/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      showJSON("cameraBox", result);
      if (result.data) {
        flashCameraId = Number(result.data.id || 0);
        fillForm(result.data);
        setStepState(1, true);
        setStepState(2, true);
        setTimeout(() => { flashCameraId = 0; }, 1500);
      }
      await loadList();
    }

    async function deleteCurrentCamera() {
      const id = numberValue("cameraId", 0);
      if (!id) throw new Error("请先选择要删除的摄像头");
      const name = textValue("cameraName") || `ID=${id}`;
      const confirmed = await showConfirm("删除摄像头", `确定删除摄像头「${name}」吗？此操作不可撤销。`);
      if (!confirmed) {
        return { code: 0, message: "已取消删除" };
      }
      const result = await requestJSON("/api/v1/cameras/delete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids: [id] })
      });
      showJSON("cameraBox", result);
      fillUsbDeviceNameSelect([]);
      updateUsbDeviceNameMode();
      resetForm("rtsp");
      setStepState(2, false);
      setStepState(3, false);
      await loadList();
    }

    async function applyCurrentToPush() {
      const id = numberValue("cameraId", 0);
      if (!id) throw new Error("请先选择要套用的摄像头");
      const result = await requestJSON(`/api/v1/cameras/${id}/apply-push`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: "{}"
      });
      showJSON("cameraBox", result);
      setStepState(3, true);
    }

    async function discoverOnvif() {
      const result = await requestJSON("/api/v1/ptz/discover?timeoutMs=8000");
      showJSON("cameraBox", result);
      const list = document.getElementById("discoveredOnvifList");
      list.innerHTML = '<option value="">（请选择发现到的 ONVIF 设备）</option>';
      const items = (result && result.data && result.data.items) || [];
      for (const item of items) {
        const endpoint = item.endpoint || (Array.isArray(item.xAddrs) ? item.xAddrs[0] : "");
        if (!endpoint) continue;
        const opt = document.createElement("option");
        opt.value = endpoint;
        opt.textContent = `${endpoint}${item.from ? ` (${item.from})` : ""}`;
        list.appendChild(opt);
      }
      setStepState(1, true);
    }

    function pickOnvifProfile(items, preferredToken) {
      if (!Array.isArray(items) || items.length === 0) return null;
      const token = String(preferredToken || "").trim();
      if (token) {
        const matched = items.find((item) => String((item && item.token) || "").trim() === token);
        if (matched) return matched;
      }
      const preferred = items.find((item) => Boolean(item && item.preferred));
      if (preferred) return preferred;
      const withRTSP = items.find((item) => String((item && item.rtspUrl) || "").trim() !== "");
      if (withRTSP) return withRTSP;
      return items[0];
    }

    function applyOnvifProfileResult(items) {
      if (!Array.isArray(items) || items.length === 0) return;
      const tokenInput = document.getElementById("cameraOnvifProfileToken");
      const rtspInput = document.getElementById("cameraOnvifRtspUrl");
      let changedToken = false;
      if (!textValue("cameraOnvifProfileToken")) {
        const first = pickOnvifProfile(items, "");
        const token = String((first && first.token) || "").trim();
        if (token) {
          tokenInput.value = token;
          changedToken = true;
        }
      }
      const selected = pickOnvifProfile(items, tokenInput.value || "");
      let candidateRTSP = String((selected && selected.rtspUrl) || "").trim();
      if (!candidateRTSP) {
        const fallback = pickOnvifProfile(items, "");
        candidateRTSP = String((fallback && fallback.rtspUrl) || "").trim();
      }
      if (!candidateRTSP) return;
      const current = textValue("cameraOnvifRtspUrl");
      const autoFilled = rtspInput.dataset.autoFilled === "1";
      if (!current || autoFilled) {
        rtspInput.value = candidateRTSP;
        rtspInput.dataset.autoFilled = "1";
        if (changedToken) {
          markFields(["cameraOnvifProfileToken", "cameraOnvifRtspUrl"]);
        } else {
          markFields(["cameraOnvifRtspUrl"]);
        }
      }
    }

    function scheduleOnvifAutoProbe() {
      const endpoint = textValue("cameraOnvifEndpoint") || textValue("onvifQuickEndpoint");
      if (!endpoint) return;
      if (onvifAutoProbeTimer) {
        clearTimeout(onvifAutoProbeTimer);
      }
      onvifAutoProbeTimer = setTimeout(() => {
        probeOnvifProfiles(true).catch(() => {});
      }, 500);
    }

    async function probeOnvifProfiles(silent) {
      syncQuickToOnvifForm(false);
      const payload = {
        endpoint: textValue("cameraOnvifEndpoint") || textValue("onvifQuickEndpoint"),
        username: textValue("cameraOnvifUsername") || textValue("onvifQuickUsername"),
        password: (document.getElementById("cameraOnvifPassword").value || "") || (document.getElementById("onvifQuickPassword").value || "")
      };
      if (!payload.endpoint) {
        if (silent) return { code: 0, message: "skip-empty-endpoint", data: [] };
        throw new Error("请先填写 ONVIF Endpoint");
      }
      const probeKey = `${payload.endpoint}@@${payload.username}@@${payload.password}`;
      if (silent && probeKey === onvifLastProbeKey) {
        return { code: 0, message: "skip-unchanged-credentials", data: [] };
      }
      const result = await requestJSON("/api/v1/ptz/profiles", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      onvifLastProbeKey = probeKey;
      if (!silent) {
        showJSON("cameraBox", result);
      }
      const items = (result && result.data) || [];
      applyOnvifProfileResult(items);
      if (!silent) {
        const hasRTSP = Array.isArray(items) && items.some((item) => String((item && item.rtspUrl) || "").trim() !== "");
        if (!hasRTSP) {
          showToast("已读取 ONVIF 配置档，但设备拒绝 GetStreamUri；请确认账号权限，或手动填写 RTSP 地址。", "info");
        }
      }
      return result;
    }

    function guessFFprobePathByFFmpegPath(ffmpegPath) {
      const value = String(ffmpegPath || "").trim();
      if (!value) return "";
      if (/ffmpeg\.exe$/i.test(value)) {
        return value.replace(/ffmpeg\.exe$/i, "ffprobe.exe");
      }
      if (/[\\/]ffmpeg$/i.test(value)) {
        return value.replace(/ffmpeg$/i, "ffprobe");
      }
      const trimmed = value.replace(/[\\/]+$/, "");
      if (!trimmed) return "";
      const isWindowsPath = /^[A-Za-z]:\\/.test(trimmed) || trimmed.includes("\\");
      const sep = isWindowsPath ? "\\" : "/";
      const binary = isWindowsPath ? "ffprobe.exe" : "ffprobe";
      return `${trimmed}${sep}${binary}`;
    }

    async function saveFFmpegPathByInput(path) {
      const ffmpegPath = String(path || "").trim();
      if (!ffmpegPath) {
        throw new Error("请先输入 FFmpeg 二进制路径或目录");
      }
      const payload = { ffmpegPath };
      const guessedFFprobe = guessFFprobePathByFFmpegPath(ffmpegPath);
      if (guessedFFprobe) {
        payload.ffprobePath = guessedFFprobe;
      }
      const result = await requestJSON("/api/v1/config", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const cfg = ((result || {}).data || {}).config || {};
      document.getElementById("cameraFFmpegPathInput").value = String(cfg.ffmpegPath || ffmpegPath);
      return result;
    }

    async function loadFFmpegPathInput() {
      const result = await requestJSON("/api/v1/config");
      const cfg = ((result || {}).data || {}).config || {};
      const value = String(cfg.ffmpegPath || "").trim();
      if (value) {
        document.getElementById("cameraFFmpegPathInput").value = value;
        setCameraFFmpegProgress(100, `当前配置已保存：${value}`, "save");
      } else {
        setCameraFFmpegProgress(0, "尚未配置 FFmpeg 路径", "detect");
      }
      return result;
    }

    async function discoverUsb() {
      const result = await requestJSON("/api/v1/push/devices");
      showJSON("cameraBox", result);
      const list = document.getElementById("discoveredUsbList");
      list.innerHTML = '<option value="">（请选择 USB 摄像头）</option>';
      const videos = (result && result.data && result.data.video) || [];
      fillUsbDeviceNameSelect(videos.map((item) => (item && item.name) || ""));
      for (const item of videos) {
        const name = (item && item.name) || "";
        if (!name) continue;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        list.appendChild(opt);
      }
      setStepState(1, true);
      setStepState(2, false);
    }

    async function autoDetectFFmpegPath() {
      setCameraFFmpegProgress(20, "正在扫描 FFmpeg 路径...", "detect");
      try {
        const result = await requestJSON("/api/v1/config/ffmpeg/auto-detect", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: "{}"
        });
        showJSON("cameraBox", result);
        const data = (result && result.data) || {};
        const ffmpegPath = String(data.ffmpegPath || "").trim();
        if (ffmpegPath) {
          document.getElementById("cameraFFmpegPathInput").value = ffmpegPath;
          showToast("FFmpeg 路径扫描成功：" + ffmpegPath, "success");
          setCameraFFmpegProgress(100, "已自动回填路径：" + ffmpegPath, "save");
        } else {
          showToast("未扫描到 FFmpeg，请手动输入路径后保存", "info");
        }
        setStepState(0, true);
        setStepState(1, false);
        return result;
      } catch (error) {
        const message = error.message || String(error);
        setCameraFFmpegProgress(0, "扫描失败：" + message, "detect");
        throw new Error("自动扫描失败：" + message + "。请手动输入 FFmpeg 二进制路径后点击“保存 FFmpeg 路径”。");
      }
    }

    const CAMERA_INSTALL_TASK_STORAGE_KEY = "gover_ffmpeg_install_task";
    let cameraInstallRunning = false;
    let cameraInstallTaskId = "";
    let cameraInstallWatchPromise = null;

    function setCameraInstallButtonState() {
      const btn = document.getElementById("btnInstallFFmpegCamera");
      if (!btn) return;
      if (cameraInstallRunning) {
        btn.textContent = "取消下载并安装 FFmpeg";
      } else {
        btn.textContent = "自动下载并安装 FFmpeg";
      }
    }

    function rememberCameraInstallTask(taskId) {
      const value = String(taskId || "").trim();
      if (!value) return;
      localStorage.setItem(CAMERA_INSTALL_TASK_STORAGE_KEY, value);
    }

    function clearRememberedCameraInstallTask() {
      localStorage.removeItem(CAMERA_INSTALL_TASK_STORAGE_KEY);
    }

    function getRememberedCameraInstallTask() {
      return String(localStorage.getItem(CAMERA_INSTALL_TASK_STORAGE_KEY) || "").trim();
    }

    function isCameraInstallTaskDone(task) {
      const status = String((task && task.status) || "").trim().toLowerCase();
      return status === "succeeded" || status === "failed" || status === "cancelled";
    }

    function applyCameraInstallTaskState(task) {
      const current = task || {};
      if (Array.isArray(current.progress) && current.progress.length) {
        applyCameraFFmpegProgressList(current.progress);
      }
      const stage = String(current.stage || "").trim() || "detect";
      const percent = Number(current.percent || 0);
      const message = String(current.message || "").trim() || "处理中...";
      setCameraFFmpegProgress(Number.isFinite(percent) ? percent : 0, message, stage);
      const ffmpegPath = String(current.ffmpegPath || "").trim();
      if (ffmpegPath) {
        document.getElementById("cameraFFmpegPathInput").value = ffmpegPath;
      }
    }

    async function queryCameraInstallTask(taskId) {
      const result = await requestJSON("/api/v1/config/ffmpeg/install/status?taskId=" + encodeURIComponent(taskId));
      return (result && result.data) || {};
    }

    async function monitorCameraInstallTaskBySSE(taskId) {
      const token = (window.GoverShared && typeof window.GoverShared.getAuthToken === "function")
        ? window.GoverShared.getAuthToken()
        : "";
      const headers = { Accept: "text/event-stream" };
      if (token) {
        headers.Authorization = "Bearer " + token;
      }
      const response = await fetch("/api/v1/config/ffmpeg/install/stream?taskId=" + encodeURIComponent(taskId), {
        method: "GET",
        headers,
        credentials: "same-origin"
      });
      if (!response.ok) {
        throw new Error("SSE HTTP " + response.status);
      }
      if (!response.body || !response.body.getReader) {
        throw new Error("浏览器不支持 SSE 流读取");
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";
      let lastData = null;

      while (true) {
        const part = await reader.read();
        const done = part.done;
        const value = part.value;
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        buffer = buffer.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        let splitAt = buffer.indexOf("\n\n");
        while (splitAt >= 0) {
          const chunk = buffer.slice(0, splitAt).trim();
          buffer = buffer.slice(splitAt + 2);
          splitAt = buffer.indexOf("\n\n");
          if (!chunk || chunk.startsWith(":")) {
            continue;
          }

          let eventName = "message";
          const dataLines = [];
          for (const line of chunk.split("\n")) {
            if (line.startsWith("event:")) {
              eventName = line.slice(6).trim() || "message";
            } else if (line.startsWith("data:")) {
              dataLines.push(line.slice(5).trimStart());
            }
          }
          if (!dataLines.length) {
            continue;
          }

          let payload = null;
          try {
            payload = JSON.parse(dataLines.join("\n"));
          } catch {
            continue;
          }

          if (eventName === "error") {
            throw new Error((payload && payload.message) || "SSE 返回错误");
          }

          const data = payload && payload.task ? payload : { task: payload };
          const task = data.task || {};
          applyCameraInstallTaskState(task);
          lastData = data;
          if (data.done || eventName === "done" || isCameraInstallTaskDone(task)) {
            return data;
          }
        }
      }

      if (lastData && isCameraInstallTaskDone(lastData.task || {})) {
        return lastData;
      }
      throw new Error("SSE 已结束但任务未完成");
    }

    async function monitorCameraInstallTaskByPolling(taskId) {
      const deadline = Date.now() + 30 * 60 * 1000;
      while (Date.now() < deadline) {
        const data = await queryCameraInstallTask(taskId);
        const task = data.task || {};
        applyCameraInstallTaskState(task);
        if (data.done || isCameraInstallTaskDone(task)) {
          return data;
        }
        await new Promise((resolve) => setTimeout(resolve, 900));
      }
      throw new Error("安装任务超时，请稍后重试");
    }

    async function monitorCameraInstallTask(taskId) {
      try {
        return await monitorCameraInstallTaskBySSE(taskId);
      } catch (sseError) {
        showToast("SSE 连接失败，自动回退到轮询：" + (sseError.message || String(sseError)), "info");
        return await monitorCameraInstallTaskByPolling(taskId);
      }
    }

    async function watchCameraInstallTask(taskId) {
      if (cameraInstallWatchPromise) {
        return cameraInstallWatchPromise;
      }
      cameraInstallRunning = true;
      cameraInstallTaskId = String(taskId || "").trim();
      rememberCameraInstallTask(cameraInstallTaskId);
      setCameraInstallButtonState();

      cameraInstallWatchPromise = (async () => {
        let finalData = null;
        try {
          finalData = await monitorCameraInstallTask(cameraInstallTaskId);
        } catch (monitorError) {
          try {
            const fallback = await queryCameraInstallTask(cameraInstallTaskId);
            if (fallback && fallback.task && isCameraInstallTaskDone(fallback.task)) {
              finalData = fallback;
            } else {
              throw monitorError;
            }
          } catch {
            throw monitorError;
          }
        }

        showJSON("cameraBox", { code: 0, message: "ok", data: finalData });
        const task = (finalData && finalData.task) || {};
        applyCameraInstallTaskState(task);

        const status = String(task.status || "").toLowerCase();
        if (status === "succeeded") {
          const ffmpegPath = String(task.ffmpegPath || "").trim();
          if (ffmpegPath) {
            document.getElementById("cameraFFmpegPathInput").value = ffmpegPath;
          }
          showToast("FFmpeg 安装完成：" + (ffmpegPath || "(未返回路径)"), "success");
          setStepState(0, true);
          setStepState(1, false);
        } else if (status === "cancelled") {
          showToast("已取消 FFmpeg 下载与安装", "info");
        } else {
          throw new Error(String(task.error || task.message || "FFmpeg 安装失败"));
        }

        clearRememberedCameraInstallTask();
        return finalData;
      })();

      try {
        return await cameraInstallWatchPromise;
      } finally {
        cameraInstallWatchPromise = null;
        cameraInstallRunning = false;
        cameraInstallTaskId = "";
        setCameraInstallButtonState();
      }
    }

    async function startCameraInstallTask() {
      setCameraFFmpegProgress(12, "正在创建安装任务...", "detect");
      const startResult = await requestJSON("/api/v1/config/ffmpeg/install", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ cdnPrefix: currentCameraFFmpegCDNPrefix() })
      });
      const startData = (startResult && startResult.data) || {};
      const taskId = String(startData.taskId || "").trim();
      if (!taskId) {
        throw new Error("安装任务创建失败：缺少任务 ID");
      }
      if (startData.task) {
        applyCameraInstallTaskState(startData.task);
      }
      showJSON("cameraBox", startResult);
      return taskId;
    }

    async function cancelCameraInstallTask() {
      const taskId = String(cameraInstallTaskId || getRememberedCameraInstallTask()).trim();
      if (!taskId) {
        throw new Error("没有可取消的安装任务");
      }
      const result = await requestJSON("/api/v1/config/ffmpeg/install/cancel", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ taskId })
      });
      const data = (result && result.data) || {};
      if (data.task) {
        applyCameraInstallTaskState(data.task);
      }
      showJSON("cameraBox", result);
      return result;
    }

    async function onCameraInstallButtonClick() {
      if (cameraInstallRunning) {
        await cancelCameraInstallTask();
        return;
      }
      const taskId = await startCameraInstallTask();
      await watchCameraInstallTask(taskId);
    }

    async function resumeCameraInstallTaskIfNeeded() {
      const taskId = getRememberedCameraInstallTask();
      if (!taskId) return;
      try {
        const data = await queryCameraInstallTask(taskId);
        const task = data.task || {};
        applyCameraInstallTaskState(task);
        if (data.done || isCameraInstallTaskDone(task)) {
          clearRememberedCameraInstallTask();
          setCameraInstallButtonState();
          return;
        }
        showToast("检测到未完成的 FFmpeg 安装任务，正在恢复进度...", "info");
        await watchCameraInstallTask(taskId);
      } catch (error) {
        clearRememberedCameraInstallTask();
        setCameraInstallButtonState();
        showToast("恢复任务失败：" + (error.message || String(error)), "error");
      }
    }

    async function saveFFmpegPathManually() {
      const manualPath = textValue("cameraFFmpegPathInput");
      setCameraFFmpegProgress(35, "正在保存手动输入路径...", "verify");
      const saved = await saveFFmpegPathByInput(manualPath);
      showJSON("cameraBox", saved);
      showToast("FFmpeg 路径已保存：" + manualPath, "success");
      setCameraFFmpegProgress(100, "FFmpeg 路径已保存：" + manualPath, "save");
      setStepState(0, true);
      setStepState(1, false);
      return saved;
    }

    document.getElementById("cameraUsbNameSelect").onchange = updateUsbDeviceNameMode;
    document.getElementById("cameraType").onchange = switchTypePanels;
    document.getElementById("cameraFFmpegCdnPreset").onchange = updateCameraFFmpegCdnCustomVisibility;
    document.getElementById("onvifQuickEndpoint").onchange = () => { syncQuickToOnvifForm(true); scheduleOnvifAutoProbe(); };
    document.getElementById("onvifQuickUsername").onchange = () => { syncQuickToOnvifForm(true); scheduleOnvifAutoProbe(); };
    document.getElementById("onvifQuickPassword").onchange = () => { syncQuickToOnvifForm(true); scheduleOnvifAutoProbe(); };
    document.getElementById("onvifQuickEndpoint").oninput = () => { syncQuickToOnvifForm(true); scheduleOnvifAutoProbe(); };
    document.getElementById("onvifQuickUsername").oninput = () => { syncQuickToOnvifForm(true); scheduleOnvifAutoProbe(); };
    document.getElementById("onvifQuickPassword").oninput = () => { syncQuickToOnvifForm(true); scheduleOnvifAutoProbe(); };
    document.getElementById("cameraOnvifEndpoint").onchange = () => { syncOnvifFormToQuick(); scheduleOnvifAutoProbe(); };
    document.getElementById("cameraOnvifUsername").onchange = () => { syncOnvifFormToQuick(); scheduleOnvifAutoProbe(); };
    document.getElementById("cameraOnvifPassword").onchange = () => { syncOnvifFormToQuick(); scheduleOnvifAutoProbe(); };
    document.getElementById("cameraOnvifEndpoint").oninput = () => { syncOnvifFormToQuick(); scheduleOnvifAutoProbe(); };
    document.getElementById("cameraOnvifUsername").oninput = () => { syncOnvifFormToQuick(); scheduleOnvifAutoProbe(); };
    document.getElementById("cameraOnvifPassword").oninput = () => { syncOnvifFormToQuick(); scheduleOnvifAutoProbe(); };
    document.getElementById("cameraOnvifRtspUrl").oninput = () => {
      document.getElementById("cameraOnvifRtspUrl").dataset.autoFilled = "0";
    };
    document.getElementById("discoveredOnvifList").onchange = () => {
      const endpoint = textValue("discoveredOnvifList");
      if (!endpoint) return;
      document.getElementById("cameraType").value = "onvif";
      document.getElementById("cameraOnvifEndpoint").value = endpoint;
      document.getElementById("onvifQuickEndpoint").value = endpoint;
      if (!textValue("cameraName")) {
        document.getElementById("cameraName").value = "ONVIF 摄像头";
      }
      switchTypePanels();
      scheduleOnvifAutoProbe();
    };
    document.getElementById("discoveredUsbList").onchange = () => {
      const deviceName = textValue("discoveredUsbList");
      if (!deviceName) return;
      document.getElementById("cameraType").value = "usb";
      setUsbDeviceNameValue(deviceName);
      if (!textValue("cameraName")) {
        document.getElementById("cameraName").value = "USB 摄像头";
      }
      switchTypePanels();
    };

    bindAction("btnCameraList", loadList, "cameraBox");
    bindAction("btnCameraSave", saveCamera, "cameraBox");
    bindAction("btnCameraDelete", deleteCurrentCamera, "cameraBox");
    bindAction("btnCameraApplyPush", applyCurrentToPush, "cameraBox");
    bindAction("btnDiscoverOnvif", discoverOnvif, "cameraBox");
    bindAction("btnProbeOnvifProfiles", probeOnvifProfiles, "cameraBox");
    bindAction("btnDiscoverUsb", discoverUsb, "cameraBox");
    bindAction("btnAutoDetectFFmpeg", autoDetectFFmpegPath, "cameraBox", { successToast: false });
    bindAction("btnSaveFFmpegPath", saveFFmpegPathManually, "cameraBox", { successToast: false });
    document.getElementById("btnInstallFFmpegCamera").onclick = () => { onCameraInstallButtonClick().catch((error) => { showToast(error.message || String(error), "error"); showJSON("cameraBox", { code: -1, message: error.message || String(error), data: error.payload || null }); }); };
    bindAction("btnCameraNew", async () => {
      resetForm("rtsp");
      showJSON("cameraBox", { code: 0, message: "已重置表单，可新建摄像头", data: {} });
    }, "cameraBox");
    bindAction("btnCameraPreviewStart", async () => {
      await startCameraPreview();
      showJSON("cameraBox", { code: 0, message: "已开启预览" });
    }, "cameraBox");
    bindAction("btnCameraPreviewStop", async () => {
      stopCameraPreview();
      showJSON("cameraBox", { code: 0, message: "已关闭预览" });
    }, "cameraBox");

    window.addEventListener("beforeunload", () => {
      stopCameraPreviewPeer();
    });

    fillUsbDeviceNameSelect([]);
    updateCameraFFmpegCdnCustomVisibility();
    setCameraInstallButtonState();
    updateUsbDeviceNameMode();
    loadFFmpegPathInput().catch(() => {});
    resumeCameraInstallTaskIfNeeded().catch(() => {});
    resetForm("rtsp");
    loadList().catch((error) => showJSON("cameraBox", { code: -1, message: error.message || String(error) }));
  </script>
</body>
</html>
